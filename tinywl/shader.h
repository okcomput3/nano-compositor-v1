// Vertex shader for simple colored rectangles
static const char *rect_vertex_shader_src =
        "#version 300 es\n"
    "precision mediump float;\n"
    "layout(location = 0) in vec2 position;\n"    // Position at location 0
    "layout(location = 1) in vec2 texcoord;\n"    // Texcoord at location 1
    "out vec2 v_texcoord;\n"
    "uniform mat3 mvp;\n"
    "void main() {\n"
    "    vec3 pos_transformed = mvp * vec3(position, 1.0);\n"
    "    gl_Position = vec4(pos_transformed.xy, 0.0, 1.0);\n"
    "    v_texcoord = texcoord;\n"
    "}\n";

const char *vertex_shader_src =
        "#version 300 es\n"
    "precision mediump float;\n"
    "layout(location = 0) in vec2 position;\n"    // Position at location 0
    "layout(location = 1) in vec2 texcoord;\n"    // Texcoord at location 1
    "out vec2 v_texcoord;\n"
    "uniform mat3 mvp;\n"
    "void main() {\n"
    "    vec3 pos_transformed = mvp * vec3(position, 1.0);\n"
    "    gl_Position = vec4(pos_transformed.xy, 0.0, 1.0);\n"
    "    v_texcoord = texcoord;\n"
    "}\n";

   /*flame shader 
const char *fragment_shader_src = 
"#version 300 es\n"
"precision mediump float;\n"
"in vec2 v_texcoord;\n"
"out vec4 frag_color;\n"
"uniform sampler2D texture_sampler_uniform;\n"
"uniform float time;\n"
"uniform vec2 iResolution;\n"
"\n"
"float rand(vec2 n) {\n"
"    return fract(sin(cos(dot(n, vec2(12.9898, 12.1414)))) * 83758.5453);\n"
"}\n"
"\n"
"float noise(vec2 n) {\n"
"    const vec2 d = vec2(0.0, 1.0);\n"
"    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n"
"    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n"
"}\n"
"\n"
"float fbm(vec2 n) {\n"
"    float total = 0.0, amplitude = 1.0;\n"
"    for (int i = 0; i < 5; i++) {\n"
"        total += noise(n) * amplitude;\n"
"        n += n * 1.7;\n"
"        amplitude *= 0.67;\n"
"    }\n"
"    return total;\n"
"}\n"
"\n"
"void main() {\n"
"    float alpha_threshold = 0.9;\n"
"    vec2 uv = v_texcoord;\n"
"    \n"
"    // Sample original texture\n"
"    vec4 tex_color = texture2D(texture_sampler_uniform, uv);\n"
"    \n"
"    // Preserve transparent areas\n"
"    if(tex_color.a <= alpha_threshold) {\n"
"        frag_color = vec4(0.0, 0.0, 0.0, 0.0).bgra;\n"
"        return;\n"
"    }\n"
"    \n"
"    // Normalize time\n"
"    float iTime = mod(time, 100.0);\n"
"    \n"
"    // Color palette from Remix 2 with white\n"
"    const vec3 c1 = vec3(0.5, 0.0, 0.1); // Red\n"
"    const vec3 c2 = vec3(0.9, 0.1, 0.0); // Orange\n"
"    const vec3 c3 = vec3(0.2, 0.1, 0.7); // Subtle blue\n"
"    const vec3 c4 = vec3(1.0, 0.9, 0.1); // Yellow\n"
"    const vec3 c7 = vec3(1.0, 1.0, 1.0); // White for highlights\n"
"    \n"
"    // Speed and shift\n"
"    vec2 speed = vec2(0.1, 0.9);\n"
"    float shift = 1.327 + sin(iTime * 2.0) / 2.4;\n"
"    float dist = 3.5 - sin(iTime * 0.4) / 1.89;\n"
"    \n"
"    // Adjust UV to position flames (base at bottom, tips at top)\n"
"    vec2 adjusted_uv = vec2(uv.x, 1.0 - uv.y * 1.2 + 0.3);\n"
"    vec2 p = adjusted_uv * dist;\n"
"    p += sin(p.yx * 8.0 + vec2(0.2, -0.3) * iTime) * 0.04;\n"
"    p += sin(p.yx * 16.0 + vec2(0.6, 0.1) * iTime) * 0.01;\n"
"    p.x -= iTime / 1.1;\n"
"    \n"
"    // Multiple FBM layers for base flames\n"
"    float q = fbm(p - iTime * 0.3 + 1.0 * sin(iTime + 0.5) / 2.0);\n"
"    float qb = fbm(p - iTime * 0.4 + 0.1 * cos(iTime) / 2.0);\n"
"    float q2 = fbm(p - iTime * 0.44 - 5.0 * cos(iTime) / 2.0) - 6.0;\n"
"    float q3 = fbm(p - iTime * 0.9 - 10.0 * cos(iTime) / 15.0) - 4.0;\n"
"    float q4 = fbm(p - iTime * 1.4 - 20.0 * sin(iTime) / 14.0) + 2.0;\n"
"    q = (q + qb - 0.4 * q2 - 2.0 * q3 + 0.6 * q4) / 3.8;\n"
"    \n"
"    // Top flame layer for taller flames\n"
"    vec2 top_flame_p = vec2(adjusted_uv.x * 5.0 + sin(iTime * 0.8) * 0.2, (adjusted_uv.y + iTime * 1.2) * 16.0);\n"
"    float top_flame_q = fbm(top_flame_p - iTime * 0.3 + 1.0 * sin(iTime + 0.5) / 2.0);\n"
"    float top_flame_qb = fbm(top_flame_p - iTime * 0.4 + 0.1 * cos(iTime) / 2.0);\n"
"    float top_flame_q2 = fbm(top_flame_p - iTime * 0.44 - 5.0 * cos(iTime) / 2.0) - 6.0;\n"
"    float top_flame_q3 = fbm(top_flame_p - iTime * 0.9 - 10.0 * cos(iTime) / 15.0) - 4.0;\n"
"    float top_flame_q4 = fbm(top_flame_p - iTime * 1.4 - 20.0 * sin(iTime) / 14.0) + 2.0;\n"
"    float top_flame_noise = (top_flame_q + top_flame_qb - 0.4 * top_flame_q2 - 2.0 * top_flame_q3 + 0.6 * top_flame_q4) / 3.8;\n"
"    top_flame_noise = clamp(top_flame_noise * 1.2, 0.0, 1.0);\n"
"    \n"
"    // Flame shapes\n"
"    float dist_from_fire_line = adjusted_uv.y;\n"
"    float flame_shape = smoothstep(0.0, 0.3, dist_from_fire_line);\n"
"    float top_flame_shape = smoothstep(0.0, 1.0, dist_from_fire_line);\n"
"    \n"
"    // Flame intensities\n"
"    vec2 r = vec2(fbm(p + q / 2.0 + iTime * speed.x - p.x - p.y), fbm(p + q - iTime * speed.y));\n"
"    float flame_intensity = q * flame_shape;\n"
"    float flame_intensity_smooth = smoothstep(0.1, 0.95, flame_intensity);\n"
"    float top_flame_intensity = top_flame_noise * top_flame_shape;\n"
"    top_flame_intensity *= (1.0 + sin(iTime * 2.0 + adjusted_uv.x * 5.0) * 0.3);\n"
"    float top_flame_intensity_smooth = smoothstep(0.15, 0.95, top_flame_intensity);\n"
"    \n"
"    // Color blending\n"
"    vec3 fire_color = mix(c1, c2, fbm(p + r));\n"
"    fire_color = mix(c3, c4, r.x);\n"
"    fire_color = vec3(1.0 / pow(fire_color + 1.61, vec3(4.0)));\n"
"    fire_color = mix(fire_color, c7, pow(flame_intensity, 2.0) * 0.1);\n"
"    fire_color = vec3(1.0, 0.2, 0.05) / pow((r.y + r.y) * max(0.0, adjusted_uv.y) + 0.1, 4.0);\n"
"    fire_color += tex_color.xyz * 0.01 * pow((r.y + r.y) * 0.65, 5.0) * mix(vec3(0.9, 0.4, 0.3), vec3(0.7, 0.5, 0.2), adjusted_uv.y);\n"
"    fire_color = fire_color / (10.0 + max(vec3(0.0), fire_color));\n"
"    \n"
"    // Top flame color\n"
"    vec2 top_r = vec2(fbm(top_flame_p + top_flame_q / 2.0 + iTime * speed.x - top_flame_p.x - top_flame_p.y), fbm(top_flame_p + top_flame_q - iTime * speed.y));\n"
"    vec3 top_fire_color = mix(c2, c4, fbm(top_flame_p + top_r));\n"
"    top_fire_color += mix(c3, c4, top_r.x) * 0.5;\n"
"    top_fire_color = vec3(1.0 / pow(top_fire_color + 1.61, vec3(4.0)));\n"
"    top_fire_color = mix(top_fire_color, c7, pow(top_flame_intensity, 2.0) * 0.95);\n"
"    top_fire_color = top_fire_color / (1.0 + max(vec3(0.0), top_fire_color));\n"
"    \n"
"    // Flickering\n"
"    float flicker = fbm(vec2(iTime * 10.0 + adjusted_uv.x * 8.0, iTime * 7.0)) * 0.4 + 0.6;\n"
"    \n"
"    // Blend with background\n"
"    vec3 final_color = mix(vec3(0.0), fire_color, flame_intensity_smooth);\n"
"    final_color = mix(final_color, top_fire_color, top_flame_intensity_smooth * 0.01);\n"
"    float final_alpha = max(flame_intensity_smooth, top_flame_intensity_smooth);\n"
"    \n"
"    // Apply texture overlay at 60% opacity\n"
"    final_color = mix(final_color, tex_color.xyz, 0.2);\n"
"    \n"
"    // Make low-intensity areas transparent\n"
"    if(final_alpha < 0.1) {\n"
"        frag_color = vec4(0.0, 0.0, 0.0, 0.0).bgra;\n"
"        return;\n"
"    }\n"
"    \n"
"    frag_color = vec4(final_color*4.0, final_alpha).bgra;\n"
"}";   */
const char *fragment_shader_src = 
"#version 300 es\n"
"precision mediump float;\n"
"in vec2 v_texcoord;\n"
"out vec4 frag_color;\n"
"uniform sampler2D texture_sampler_uniform;\n"
"uniform float time;\n"
"uniform vec2 iResolution;\n"
"\n"
"float rand(vec2 n) {\n"
"    return fract(sin(cos(dot(n, vec2(12.9898, 12.1414)))) * 83758.5453);\n"
"}\n"
"\n"
"float noise(vec2 n) {\n"
"    const vec2 d = vec2(0.0, 1.0);\n"
"    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n"
"    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n"
"}\n"
"\n"
"float fbm(vec2 n) {\n"
"    float total = 0.0, amplitude = 1.0;\n"
"    for (int i = 0; i < 5; i++) {\n"
"        total += noise(n) * amplitude;\n"
"        n += n * 1.7;\n"
"        amplitude *= 0.67;\n"
"    }\n"
"    return total;\n"
"}\n"
"\n"
"// Hue to RGB conversion\n"
"vec3 hueToRGB(float hue) {\n"
"    float r = abs(hue * 6.0 - 3.0) - 1.0;\n"
"    float g = 2.0 - abs(hue * 6.0 - 2.0);\n"
"    float b = 2.0 - abs(hue * 6.0 - 4.0);\n"
"    return clamp(vec3(r, g, b), 0.0, 1.0);\n"
"}\n"
"\n"
"float roundedTextureMask(vec2 uv, float radiusPixels, out float borderGradient) {\n"
"    // Convert UV to pixel coordinates\n"
"    vec2 pixelCoord = uv * iResolution;\n"
"    vec2 rectSize = iResolution;\n"
"    \n"
"    // Initialize border gradient\n"
"    borderGradient = 0.0;\n"
"    float borderWidthPixels = 1.0; // Thin border for delicate outline\n"
"    float smoothingFactor = 1.0; // Crisp transition for thin border\n"
"    \n"
"    // Define the four corners in pixel coordinates\n"
"    vec2 topLeft = vec2(radiusPixels, radiusPixels);\n"
"    vec2 topRight = vec2(rectSize.x - radiusPixels, radiusPixels);\n"
"    vec2 bottomLeft = vec2(radiusPixels, rectSize.y - radiusPixels);\n"
"    vec2 bottomRight = vec2(rectSize.x - radiusPixels, rectSize.y - radiusPixels);\n"
"    \n"
"    float mask = 1.0;\n"
"    vec2 corner_dist;\n"
"    float dist_to_center;\n"
"    \n"
"    // Top-left corner\n"
"    if (pixelCoord.x < radiusPixels && pixelCoord.y < radiusPixels) {\n"
"        corner_dist = topLeft - pixelCoord;\n"
"        dist_to_center = length(corner_dist);\n"
"        mask = smoothstep(radiusPixels + 1.0, radiusPixels - 1.0, dist_to_center);\n"
"        float cornerBorderWidth = borderWidthPixels * 0.5;\n"
"        float innerEdge = radiusPixels - cornerBorderWidth;\n"
"        float outerEdge = radiusPixels + cornerBorderWidth;\n"
"        if (dist_to_center <= outerEdge && dist_to_center >= innerEdge - smoothingFactor) {\n"
"            borderGradient = smoothstep(outerEdge + smoothingFactor, innerEdge - smoothingFactor, dist_to_center);\n"
"        }\n"
"        return mask;\n"
"    }\n"
"    \n"
"    // Top-right corner\n"
"    if (pixelCoord.x > rectSize.x - radiusPixels && pixelCoord.y < radiusPixels) {\n"
"        corner_dist = pixelCoord - topRight;\n"
"        dist_to_center = length(corner_dist);\n"
"        mask = smoothstep(radiusPixels + 1.0, radiusPixels - 1.0, dist_to_center);\n"
"        float cornerBorderWidth = borderWidthPixels * 0.5;\n"
"        float innerEdge = radiusPixels - cornerBorderWidth;\n"
"        float outerEdge = radiusPixels + cornerBorderWidth;\n"
"        if (dist_to_center <= outerEdge && dist_to_center >= innerEdge - smoothingFactor) {\n"
"            borderGradient = smoothstep(outerEdge + smoothingFactor, innerEdge - smoothingFactor, dist_to_center);\n"
"        }\n"
"        return mask;\n"
"    }\n"
"    \n"
"    // Bottom-left corner\n"
"    if (pixelCoord.x < radiusPixels && pixelCoord.y > rectSize.y - radiusPixels) {\n"
"        corner_dist = bottomLeft - pixelCoord;\n"
"        dist_to_center = length(corner_dist);\n"
"        mask = smoothstep(radiusPixels + 1.0, radiusPixels - 1.0, dist_to_center);\n"
"        float cornerBorderWidth = borderWidthPixels * 0.5;\n"
"        float innerEdge = radiusPixels - cornerBorderWidth;\n"
"        float outerEdge = radiusPixels + cornerBorderWidth;\n"
"        if (dist_to_center <= outerEdge && dist_to_center >= innerEdge - smoothingFactor) {\n"
"            borderGradient = smoothstep(outerEdge + smoothingFactor, innerEdge - smoothingFactor, dist_to_center);\n"
"        }\n"
"        return mask;\n"
"    }\n"
"    \n"
"    // Bottom-right corner\n"
"    if (pixelCoord.x > rectSize.x - radiusPixels && pixelCoord.y > rectSize.y - radiusPixels) {\n"
"        corner_dist = pixelCoord - bottomRight;\n"
"        dist_to_center = length(corner_dist);\n"
"        mask = smoothstep(radiusPixels + 1.0, radiusPixels - 1.0, dist_to_center);\n"
"        float cornerBorderWidth = borderWidthPixels * 0.5;\n"
"        float innerEdge = radiusPixels - cornerBorderWidth;\n"
"        float outerEdge = radiusPixels + cornerBorderWidth;\n"
"        if (dist_to_center <= outerEdge && dist_to_center >= innerEdge - smoothingFactor) {\n"
"            borderGradient = smoothstep(outerEdge + smoothingFactor, innerEdge - smoothingFactor, dist_to_center);\n"
"        }\n"
"        return mask;\n"
"    }\n"
"    \n"
"    // Handle straight edges\n"
"    float distToLeft = pixelCoord.x;\n"
"    float distToRight = rectSize.x - pixelCoord.x;\n"
"    float distToTop = pixelCoord.y;\n"
"    float distToBottom = rectSize.y - pixelCoord.y;\n"
"    float minDistToEdge = min(min(distToLeft, distToRight), min(distToTop, distToBottom));\n"
"    if (minDistToEdge < borderWidthPixels) {\n"
"        borderGradient = smoothstep(borderWidthPixels + smoothingFactor, borderWidthPixels - smoothingFactor, minDistToEdge);\n"
"    }\n"
"    return 1.0;\n"
"}\n"
"\n"
"void main() {\n"
"    float alpha_threshold = 0.9;\n"
"    vec2 uv = v_texcoord;\n"
"    \n"
"    // Sample original texture\n"
"    vec4 tex_color = texture2D(texture_sampler_uniform, uv);\n"
"    \n"
"    // Preserve transparent areas\n"
"    if(tex_color.a <= alpha_threshold) {\n"
"        frag_color = vec4(0.0, 0.0, 0.0, 0.0).bgra;\n"
"        return;\n"
"    }\n"
"    \n"
"    // Normalize time\n"
"    float iTime = mod(time, 100.0);\n"
"    \n"
"    // Color palette from Remix 2 with white\n"
"    const vec3 c1 = vec3(0.5, 0.0, 0.1); // Red\n"
"    const vec3 c2 = vec3(0.9, 0.1, 0.0); // Orange\n"
"    const vec3 c3 = vec3(0.2, 0.1, 0.7); // Subtle blue\n"
"    const vec3 c4 = vec3(1.0, 0.9, 0.1); // Yellow\n"
"    const vec3 c7 = vec3(1.0, 1.0, 1.0); // White for highlights\n"
"    \n"
"    // Speed and shift\n"
"    vec2 speed = vec2(0.1, 0.9);\n"
"    float shift = 1.327 + sin(iTime * 2.0) / 2.4;\n"
"    float dist = 3.5 - sin(iTime * 0.4) / 1.89;\n"
"    \n"
"    // Adjust UV to position flames (base at bottom, tips at top)\n"
"    vec2 adjusted_uv = vec2(uv.x, 1.0 - uv.y * 1.2 + 0.3);\n"
"    vec2 p = adjusted_uv * dist;\n"
"    p += sin(p.yx * 8.0 + vec2(0.2, -0.3) * iTime) * 0.04;\n"
"    p += sin(p.yx * 16.0 + vec2(0.6, 0.1) * iTime) * 0.01;\n"
"    p.x -= iTime / 1.1;\n"
"    \n"
"    // Multiple FBM layers for base flames\n"
"    float q = fbm(p - iTime * 0.3 + 1.0 * sin(iTime + 0.5) / 2.0);\n"
"    float qb = fbm(p - iTime * 0.4 + 0.1 * cos(iTime) / 2.0);\n"
"    float q2 = fbm(p - iTime * 0.44 - 5.0 * cos(iTime) / 2.0) - 6.0;\n"
"    float q3 = fbm(p - iTime * 0.9 - 10.0 * cos(iTime) / 15.0) - 4.0;\n"
"    float q4 = fbm(p - iTime * 1.4 - 20.0 * sin(iTime) / 14.0) + 2.0;\n"
"    q = (q + qb - 0.4 * q2 - 2.0 * q3 + 0.6 * q4) / 3.8;\n"
"    \n"
"    // Top flame layer for taller flames\n"
"    vec2 top_flame_p = vec2(adjusted_uv.x * 5.0 + sin(iTime * 0.8) * 0.2, (adjusted_uv.y + iTime * 1.2) * 16.0);\n"
"    float top_flame_q = fbm(top_flame_p - iTime * 0.3 + 1.0 * sin(iTime + 0.5) / 2.0);\n"
"    float top_flame_qb = fbm(top_flame_p - iTime * 0.4 + 0.1 * cos(iTime) / 2.0);\n"
"    float top_flame_q2 = fbm(top_flame_p - iTime * 0.44 - 5.0 * cos(iTime) / 2.0) - 6.0;\n"
"    float top_flame_q3 = fbm(top_flame_p - iTime * 0.9 - 10.0 * cos(iTime) / 15.0) - 4.0;\n"
"    float top_flame_q4 = fbm(top_flame_p - iTime * 1.4 - 20.0 * sin(iTime) / 14.0) + 2.0;\n"
"    float top_flame_noise = (top_flame_q + top_flame_qb - 0.4 * top_flame_q2 - 2.0 * top_flame_q3 + 0.6 * top_flame_q4) / 3.8;\n"
"    top_flame_noise = clamp(top_flame_noise * 1.2, 0.0, 1.0);\n"
"    \n"
"    // Flame shapes\n"
"    float dist_from_fire_line = adjusted_uv.y;\n"
"    float flame_shape = smoothstep(0.0, 0.3, dist_from_fire_line);\n"
"    float top_flame_shape = smoothstep(0.0, 1.0, dist_from_fire_line);\n"
"    \n"
"    // Flame intensities\n"
"    vec2 r = vec2(fbm(p + q / 2.0 + iTime * speed.x - p.x - p.y), fbm(p + q - iTime * speed.y));\n"
"    float flame_intensity = q * flame_shape;\n"
"    float flame_intensity_smooth = smoothstep(0.1, 0.95, flame_intensity);\n"
"    float top_flame_intensity = top_flame_noise * top_flame_shape;\n"
"    top_flame_intensity *= (1.0 + sin(iTime * 2.0 + adjusted_uv.x * 5.0) * 0.3);\n"
"    float top_flame_intensity_smooth = smoothstep(0.15, 0.95, top_flame_intensity);\n"
"    \n"
"    // Color blending\n"
"    vec3 fire_color = mix(c1, c2, fbm(p + r));\n"
"    fire_color = mix(c3, c4, r.x);\n"
"    fire_color = vec3(1.0 / pow(fire_color + 1.61, vec3(4.0)));\n"
"    fire_color = mix(fire_color, c7, pow(flame_intensity, 2.0) * 0.1);\n"
"    fire_color = vec3(1.0, 0.2, 0.05) / pow((r.y + r.y) * max(0.0, adjusted_uv.y) + 0.1, 4.0);\n"
"    fire_color += tex_color.xyz * 0.01 * pow((r.y + r.y) * 0.65, 5.0) * mix(vec3(0.9, 0.4, 0.3), vec3(0.7, 0.5, 0.2), adjusted_uv.y);\n"
"    fire_color = fire_color / (10.0 + max(vec3(0.0), fire_color));\n"
"    \n"
"    // Top flame color\n"
"    vec2 top_r = vec2(fbm(top_flame_p + top_flame_q / 2.0 + iTime * speed.x - top_flame_p.x - top_flame_p.y), fbm(top_flame_p + top_flame_q - iTime * speed.y));\n"
"    vec3 top_fire_color = mix(c2, c4, fbm(top_flame_p + top_r));\n"
"    top_fire_color += mix(c3, c4, top_r.x) * 0.5;\n"
"    top_fire_color = vec3(1.0 / pow(top_fire_color + 1.61, vec3(4.0)));\n"
"    top_fire_color = mix(top_fire_color, c7, pow(top_flame_intensity, 2.0) * 0.95);\n"
"    top_fire_color = top_fire_color / (1.0 + max(vec3(0.0), top_fire_color));\n"
"    \n"
"    // Flickering\n"
"    float flicker = fbm(vec2(iTime * 10.0 + adjusted_uv.x * 8.0, iTime * 7.0)) * 0.4 + 0.6;\n"
"    \n"
"    // Blend with background\n"
"    vec3 final_color = mix(vec3(0.0), fire_color, flame_intensity_smooth);\n"
"    final_color = mix(final_color, top_fire_color, top_flame_intensity_smooth * 0.01);\n"
"    float final_alpha = max(flame_intensity_smooth, top_flame_intensity_smooth);\n"
"    \n"
"    // Apply texture overlay at 60% opacity\n"
"    final_color = mix(final_color, tex_color.xyz, 0.2);\n"
"    \n"
"    // Apply rounded corners and border\n"
"    float borderGradient;\n"
"    float cornerRadiusPixels = 9.0; // Proportional radius for small icons\n"
"    float texture_mask = roundedTextureMask(v_texcoord, cornerRadiusPixels, borderGradient);\n"
"    final_alpha *= texture_mask;\n"
"    \n"
"    // Make low-intensity areas transparent\n"
"    if(final_alpha < 0.1) {\n"
"        frag_color = vec4(0.0, 0.0, 0.0, 0.0).bgra;\n"
"        return;\n"
"    }\n"
"    \n"
"    // Apply multi-hue border color\n"
"    float hue = fract((v_texcoord.x + v_texcoord.y + time * 0.1) * 0.5);\n"
"    vec3 borderColor = hueToRGB(hue);\n"
"    final_color = mix(final_color, borderColor, borderGradient * texture_mask);\n"
"    \n"
"    frag_color = vec4(final_color * 4.0, final_alpha).bgra;\n"
"}";


// Vertex shader for simple colored rectangles
static const char *panel_vertex_shader_src =
        "#version 300 es\n"
    "precision mediump float;\n"
    "layout(location = 0) in vec2 position;\n"    // Position at location 0
    "layout(location = 1) in vec2 texcoord;\n"    // Texcoord at location 1
    "out vec2 v_texcoord;\n"
    "uniform mat3 mvp;\n"
    "void main() {\n"
    "    vec3 pos_transformed = mvp * vec3(position, 1.0);\n"
    "    gl_Position = vec4(pos_transformed.xy, 0.0, 1.0);\n"
    "    v_texcoord = texcoord;\n"
    "}\n";

/*
static const char *panel_fragment_shader_src =
    "#version 300 es\n"
    "precision mediump float;\n"
    "\n"
    "in vec2 v_texcoord; // Normalized UV for the panel quad itself (0,0 to 1,1)\n"
    "out vec4 frag_color;\n"
    "\n"
    "// Time and resolution uniforms for the background animation\n"
    "uniform float time;\n"
    "uniform vec2 iResolution; // Resolution of the viewport/target this shader draws to\n"
    "\n"
    "// Uniforms for the preview functionality\n"
    "uniform sampler2D u_previewTexture;     // The window texture for the preview\n"
    "uniform bool u_isPreviewActive;         // Flag: is there a preview to draw?\n"
    "uniform vec4 u_previewRect;           // Preview position and size on panel: x, y, w, h (normalized 0-1 relative to panel's own UVs)\n"
    "uniform mat3 u_previewTexTransform;   // Transform for sampling the preview texture\n"
    "\n"
    "// --- Start of new \"Electric Grid\" background --- \n"
    "\n"
    "// Simple 2D rotation matrix\n"
    "mat2 rotate2D(float angle) {\n"
    "    float s = sin(angle);\n"
    "    float c = cos(angle);\n"
    "    return mat2(c, -s, s, c);\n"
    "}\n"
    "\n"
    "// Hash function for pseudo-randomness\n"
    "float hash(vec2 p) {\n"
    "    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n"
    "}\n"
    "\n"
    "vec4 getElectricGridColor() {\n"
    "    // Use gl_FragCoord.xy for a background that maps to screen pixels.\n"
    "    // This makes the effect appear 'behind' the panel.\n"
    "    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n"
    "    float iTime = time * 0.35; // Control overall animation speed\n"
    "\n"
    "    vec3 col = vec3(0.01, 0.02, 0.05); // Dark blue-ish background\n"
    "\n"
    "    // Apply a slight rotation and zoom to the coordinate system for dynamism\n"
    "    uv *= rotate2D(iTime * 0.05);\n"
    "    uv *= (1.0 + 0.05 * sin(iTime * 0.2));\n"
    "\n"
    "    float grid_scale = 8.0;\n"
    "    vec2 grid_uv = uv * grid_scale;\n"
    "\n"
    "    // Animated scrolling for the grid\n"
    "    grid_uv.x += iTime * 0.3;\n"
    "    grid_uv.y -= iTime * 0.2;\n"
    "\n"
    "    vec2 grid_id = floor(grid_uv);\n"
    "    vec2 grid_fract = fract(grid_uv);\n"
    "\n"
    "    // Grid lines\n"
    "    float line_width = 0.03;\n"
    "    float line_intensity_x = smoothstep(line_width, 0.0, min(grid_fract.x, 1.0 - grid_fract.x));\n"
    "    float line_intensity_y = smoothstep(line_width, 0.0, min(grid_fract.y, 1.0 - grid_fract.y));\n"
    "    float grid_lines = max(line_intensity_x, line_intensity_y);\n"
    "\n"
    "    // Pulsing effect for grid lines\n"
    "    float pulse_wave = 0.6 + 0.4 * sin(grid_id.x * 0.7 - iTime * 2.5 + grid_id.y * 0.5);\n"
    "    grid_lines *= pulse_wave;\n"
    "\n"
    "    vec3 grid_color = vec3(0.1, 0.6, 1.0); // Bright electric blue\n"
    "    col = mix(col, grid_color, grid_lines * 0.7); // Blend grid lines\n"
    "\n"
    "    // Dots at grid intersections\n"
    "    float dot_radius = 0.08;\n"
    "    float dist_to_center = length(grid_fract - 0.5);\n"
    "    float dots = smoothstep(dot_radius, dot_radius - 0.02, dist_to_center); // Smaller, sharper dots\n"
    "    \n"
    "    // Pulsing and slightly randomized dots\n"
    "    float dot_pulse = 0.5 + 0.5 * sin(hash(grid_id) * 6.283 + iTime * 4.0);\n"
    "    dots *= dot_pulse;\n"
    "    vec3 dot_color = vec3(0.8, 1.0, 1.0); // Cyan/white dots\n"
    "    col = mix(col, dot_color, dots * 0.4);\n"
    "\n"
    "    // Add some subtle secondary, thinner, faster moving grid lines\n"
    "    vec2 fine_grid_uv = uv * grid_scale * 2.5;\n"
    "    fine_grid_uv.x -= iTime * 0.7;\n"
    "    fine_grid_uv.y += iTime * 0.5;\n"
    "    vec2 fine_grid_fract = fract(fine_grid_uv);\n"
    "    float fine_line_width = 0.01;\n"
    "    float fine_intensity_x = smoothstep(fine_line_width, 0.0, min(fine_grid_fract.x, 1.0 - fine_grid_fract.x));\n"
    "    float fine_intensity_y = smoothstep(fine_line_width, 0.0, min(fine_grid_fract.y, 1.0 - fine_grid_fract.y));\n"
    "    float fine_grid_lines = max(fine_intensity_x, fine_intensity_y);\n"
    "    col = mix(col, grid_color * 0.5, fine_grid_lines * 0.2); // Dimmer fine lines\n"
    "\n"
    "    // Clamp final color and set alpha for the panel background\n"
    "    return vec4(clamp(col, 0.0, 1.0), 0.8); // MODIFIED ALPHA HERE \n"
    "}\n"
    "// --- End of new \"Electric Grid\" background --- \n"
    "\n"
    "void main() {\n"
    "    // Start with the new Electric Grid animation as the background\n"
    "    vec4 background_color = getElectricGridColor();\n"
    "    vec4 final_pixel_color = background_color;\n"
    "\n"
    "    // Layer the preview on top if active\n"
    "    // THIS PREVIEW LOGIC IS IDENTICAL TO YOUR ORIGINAL OCTAGRAMS SHADER\n"
    "    if (u_isPreviewActive) {\n"
    "        // Check if we're inside the preview rectangle\n"
    "        bool is_inside_preview_x = (v_texcoord.x >= u_previewRect.x && v_texcoord.x < (u_previewRect.x + u_previewRect.z));\n"
    "        bool is_inside_preview_y = (v_texcoord.y >= u_previewRect.y && v_texcoord.y < (u_previewRect.y + u_previewRect.w));\n"
    "        \n"
    "        if (is_inside_preview_x && is_inside_preview_y) {\n"
    "            // We're inside the preview area - sample the preview texture\n"
    "            vec3 transformed_uv_homogeneous = u_previewTexTransform * vec3(v_texcoord, 1.0);\n"
    "            vec2 final_sample_uv = transformed_uv_homogeneous.xy;\n"
    "            \n"
    "            vec4 preview_sample = texture(u_previewTexture, final_sample_uv);\n"
    "            \n"
    "            if (preview_sample.a > 0.05) {\n"
    "                // Blend the preview over the background (using the same mix as your original)\n"
    "                final_pixel_color = mix(background_color, preview_sample, preview_sample.a);\n"
    "            }\n"
    "        }\n"
    "    }\n"
    "\n"
    "    frag_color = final_pixel_color.bgra;\n"
    "}";*/
//orgininal
/*    
static const char *panel_fragment_shader_src =
    "#version 300 es\n"
    "precision mediump float;\n"
    "\n"
    "in vec2 v_texcoord; // Normalized UV for the panel quad itself (0,0 to 1,1)\n"
    "out vec4 frag_color;\n"
    "\n"
    "// Time and resolution uniforms for the background animation\n"
    "uniform float time;\n"
    "uniform vec2 iResolution; // Resolution of the viewport/target this shader draws to\n"
    "uniform vec2 panelDimensions; // Actual panel dimensions in pixels\n"
    "\n"
    "// Uniforms for the preview functionality\n"
    "uniform sampler2D u_previewTexture;     // The window texture for the preview\n"
    "uniform bool u_isPreviewActive;         // Flag: is there a preview to draw?\n"
    "uniform vec4 u_previewRect;           // Preview position and size on panel: x, y, w, h (normalized 0-1 relative to panel's own UVs)\n"
    "uniform mat3 u_previewTexTransform;   // Transform for sampling the preview texture\n"
    "\n"
    "// Function to calculate rounded top corner mask using pixel-based dimensions\n"
    "float roundedTopCornerMask(vec2 uv, float radiusPixels) {\n"
    "    // Convert UV coordinates to pixel coordinates\n"
    "    vec2 pixelCoord = uv * panelDimensions;\n"
    "    \n"
    "    // --- THE FIX IS HERE --- \n"
    "    // Check the TOP of the panel (where pixelCoord.y is SMALLER than radiusPixels)\n"
    "    if (pixelCoord.y > radiusPixels) {\n"
    "        return 1.0; // The non-rounded part is fully opaque\n"
    "    }\n"
    "    \n"
    "    // We are now in the top-most part of the panel. Check if we're in a corner.\n"
    "    vec2 corner_dist;\n"
    "    \n"
    "    // Top-left corner (pixelCoord.x is small)\n"
    "    if (pixelCoord.x < radiusPixels) {\n"
    "        corner_dist = vec2(radiusPixels - pixelCoord.x, radiusPixels - pixelCoord.y);\n"
    "        float dist_to_center = length(corner_dist);\n"
    "        return smoothstep(radiusPixels + 1.0, radiusPixels - 1.0, dist_to_center);\n"
    "    }\n"
    "    \n"
    "    // Top-right corner (pixelCoord.x is large)\n"
    "    if (pixelCoord.x > (panelDimensions.x - radiusPixels)) {\n"
    "        corner_dist = vec2(pixelCoord.x - (panelDimensions.x - radiusPixels), radiusPixels - pixelCoord.y);\n"
    "        float dist_to_center = length(corner_dist);\n"
    "        return smoothstep(radiusPixels + 1.0, radiusPixels - 1.0, dist_to_center);\n"
    "    }\n"
    "    \n"
    "    // The area between the corners at the top is fully opaque\n"
    "    return 1.0;\n"
    "}\n"
    "\n"
    "// ... (The rest of your shader code remains exactly the same) ...\n"
    "\n"
    "mat2 rotate2D(float angle) {\n"
    "    float s = sin(angle);\n"
    "    float c = cos(angle);\n"
    "    return mat2(c, -s, s, c);\n"
    "}\n"
    "\n"
    "float hash(vec2 p) {\n"
    "    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n"
    "}\n"
    "\n"
    "vec4 getElectricGridColor() {\n"
    "    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n"
    "    float iTime = time * 0.35;\n"
    "    vec3 col = vec3(0.01, 0.02, 0.05);\n"
    "    uv *= rotate2D(iTime * 0.05);\n"
    "    uv *= (1.0 + 0.05 * sin(iTime * 0.2));\n"
    "    float grid_scale = 8.0;\n"
    "    vec2 grid_uv = uv * grid_scale;\n"
    "    grid_uv.x += iTime * 0.3;\n"
    "    grid_uv.y -= iTime * 0.2;\n"
    "    vec2 grid_id = floor(grid_uv);\n"
    "    vec2 grid_fract = fract(grid_uv);\n"
    "    float line_width = 0.03;\n"
    "    float line_intensity_x = smoothstep(line_width, 0.0, min(grid_fract.x, 1.0 - grid_fract.x));\n"
    "    float line_intensity_y = smoothstep(line_width, 0.0, min(grid_fract.y, 1.0 - grid_fract.y));\n"
    "    float grid_lines = max(line_intensity_x, line_intensity_y);\n"
    "    float pulse_wave = 0.6 + 0.4 * sin(grid_id.x * 0.7 - iTime * 2.5 + grid_id.y * 0.5);\n"
    "    grid_lines *= pulse_wave;\n"
    "    vec3 grid_color = vec3(0.1, 0.6, 1.0);\n"
    "    col = mix(col, grid_color, grid_lines * 0.7);\n"
    "    float dot_radius = 0.08;\n"
    "    float dist_to_center = length(grid_fract - 0.5);\n"
    "    float dots = smoothstep(dot_radius, dot_radius - 0.02, dist_to_center);\n"
    "    float dot_pulse = 0.5 + 0.5 * sin(hash(grid_id) * 6.283 + iTime * 4.0);\n"
    "    dots *= dot_pulse;\n"
    "    vec3 dot_color = vec3(0.8, 1.0, 1.0);\n"
    "    col = mix(col, dot_color, dots * 0.4);\n"
    "    vec2 fine_grid_uv = uv * grid_scale * 2.5;\n"
    "    fine_grid_uv.x -= iTime * 0.7;\n"
    "    fine_grid_uv.y += iTime * 0.5;\n"
    "    vec2 fine_grid_fract = fract(fine_grid_uv);\n"
    "    float fine_line_width = 0.01;\n"
    "    float fine_intensity_x = smoothstep(fine_line_width, 0.0, min(fine_grid_fract.x, 1.0 - fine_grid_fract.x));\n"
    "    float fine_intensity_y = smoothstep(fine_line_width, 0.0, min(fine_grid_fract.y, 1.0 - fine_grid_fract.y));\n"
    "    float fine_grid_lines = max(fine_intensity_x, fine_intensity_y);\n"
    "    col = mix(col, grid_color * 0.5, fine_grid_lines * 0.2);\n"
    "    return vec4(clamp(col, 0.0, 1.0), 0.8);\n"
    "}\n"
    "\n"
    "void main() {\n"
    "    float corner_radius_pixels = 40.0;\n"
    "    float corner_mask = roundedTopCornerMask(v_texcoord, corner_radius_pixels);\n"
    "    vec4 background_color = getElectricGridColor();\n"
    "    background_color.a *= corner_mask;\n"
    "    vec4 final_pixel_color = background_color;\n"
    "\n"
    "    if (u_isPreviewActive) {\n"
    "        bool is_inside_preview_x = (v_texcoord.x >= u_previewRect.x && v_texcoord.x < (u_previewRect.x + u_previewRect.z));\n"
    "        bool is_inside_preview_y = (v_texcoord.y >= u_previewRect.y && v_texcoord.y < (u_previewRect.y + u_previewRect.w));\n"
    "        \n"
    "        if (is_inside_preview_x && is_inside_preview_y) {\n"
    "            vec3 transformed_uv_homogeneous = u_previewTexTransform * vec3(v_texcoord, 1.0);\n"
    "            vec2 final_sample_uv = transformed_uv_homogeneous.xy;\n"
    "            vec4 preview_sample = texture(u_previewTexture, final_sample_uv);\n"
    "            \n"
    "            if (preview_sample.a > 0.05) {\n"
    "                final_pixel_color = mix(background_color, preview_sample, preview_sample.a);\n"
    "            }\n"
    "        }\n"
    "    }\n"
    "\n"
    "    frag_color = final_pixel_color.bgra;\n"
    "}";
*/


/* //original panel shader
static const char *panel_fragment_shader_src =
    "#version 300 es\n"
    "precision mediump float;\n"
    "\n"
    "in vec2 v_texcoord; // Normalized UV for the panel quad itself (0,0 to 1,1)\n"
    "out vec4 frag_color;\n"
    "\n"
    "// Time and resolution uniforms for the background animation\n"
    "uniform float time;\n"
    "uniform vec2 iResolution; // Resolution of the viewport/target this shader draws to\n"
    "uniform vec2 panelDimensions; // Actual panel dimensions in pixels\n"
    "\n"
    "// Uniforms for the preview functionality\n"
    "uniform sampler2D u_previewTexture;     // The window texture for the preview\n"
    "uniform bool u_isPreviewActive;         // Flag: is there a preview to draw?\n"
    "uniform vec4 u_previewRect;           // Preview position and size on panel: x, y, w, h (normalized 0-1 relative to panel's own UVs)\n"
    "uniform mat3 u_previewTexTransform;   // Transform for sampling the preview texture\n"
    "\n"
    "// Function to calculate rounded top corner mask and border gradient using pixel-based dimensions\n"
    "float roundedTopCornerMask(vec2 uv, float radiusPixels, out float borderGradient) {\n"
    "    // Convert UV coordinates to pixel coordinates\n"
    "    vec2 pixelCoord = uv * panelDimensions;\n"
    "    \n"
    "    // Initialize border gradient (0.0 = no border, 1.0 = full border intensity)\n"
    "    borderGradient = 0.0;\n"
    "    float borderWidthPixels = 2.0; // Width of the border in pixels for straight edges\n"
    "    float smoothingFactor = 1.0; // Controls smoothness of border transition\n"
    "    \n"
    "    // Check the TOP of the panel (where pixelCoord.y is SMALLER than radiusPixels)\n"
    "    if (pixelCoord.y > radiusPixels) {\n"
    "        // Handle straight edges (left, right, bottom)\n"
    "        float distToLeft = pixelCoord.x;\n"
    "        float distToRight = panelDimensions.x - pixelCoord.x;\n"
    "        float distToBottom = panelDimensions.y - pixelCoord.y;\n"
    "        float minDistToEdge = min(min(distToLeft, distToRight), distToBottom);\n"
    "        if (minDistToEdge < borderWidthPixels) {\n"
    "            borderGradient = smoothstep(borderWidthPixels + smoothingFactor, borderWidthPixels - smoothingFactor, minDistToEdge);\n"
    "        }\n"
    "        return 1.0; // The non-rounded part is fully opaque\n"
    "    }\n"
    "    \n"
    "    // We are now in the top-most part of the panel. Check if we're in a corner.\n"
    "    vec2 corner_dist;\n"
    "    float mask = 1.0;\n"
    "    \n"
    "    // Top-left corner (pixelCoord.x is small)\n"
    "    if (pixelCoord.x < radiusPixels) {\n"
    "        corner_dist = vec2(radiusPixels - pixelCoord.x, radiusPixels - pixelCoord.y);\n"
    "        float dist_to_center = length(corner_dist);\n"
    "        mask = smoothstep(radiusPixels + 1.0, radiusPixels - 1.0, dist_to_center);\n"
    "        // Calculate smoother border gradient for the corner with halved thickness\n"
    "        float cornerBorderWidth = borderWidthPixels * 0.5; // Halve the border width for corners\n"
    "        float innerEdge = radiusPixels - cornerBorderWidth;\n"
    "        float outerEdge = radiusPixels + cornerBorderWidth;\n"
    "        if (dist_to_center <= outerEdge && dist_to_center >= innerEdge - smoothingFactor) {\n"
    "            borderGradient = smoothstep(outerEdge + smoothingFactor, innerEdge - smoothingFactor, dist_to_center);\n"
    "        }\n"
    "        return mask;\n"
    "    }\n"
    "    \n"
    "    // Top-right corner (pixelCoord.x is large)\n"
    "    if (pixelCoord.x > (panelDimensions.x - radiusPixels)) {\n"
    "        corner_dist = vec2(pixelCoord.x - (panelDimensions.x - radiusPixels), radiusPixels - pixelCoord.y);\n"
    "        float dist_to_center = length(corner_dist);\n"
    "        mask = smoothstep(radiusPixels + 1.0, radiusPixels - 1.0, dist_to_center);\n"
    "        // Calculate smoother border gradient for the corner with halved thickness\n"
    "        float cornerBorderWidth = borderWidthPixels * 0.5; // Halve the border width for corners\n"
    "        float innerEdge = radiusPixels - cornerBorderWidth;\n"
    "        float outerEdge = radiusPixels + cornerBorderWidth;\n"
    "        if (dist_to_center <= outerEdge && dist_to_center >= innerEdge - smoothingFactor) {\n"
    "            borderGradient = smoothstep(outerEdge + smoothingFactor, innerEdge - smoothingFactor, dist_to_center);\n"
    "        }\n"
    "        return mask;\n"
    "    }\n"
    "    \n"
    "    // The area between the corners at the top is fully opaque\n"
    "    // Check top edge for border\n"
    "    if (pixelCoord.y < borderWidthPixels) {\n"
    "        borderGradient = smoothstep(borderWidthPixels + smoothingFactor, borderWidthPixels - smoothingFactor, pixelCoord.y);\n"
    "    }\n"
    "    return 1.0;\n"
    "}\n"
    "\n"
    "mat2 rotate2D(float angle) {\n"
    "    float s = sin(angle);\n"
    "    float c = cos(angle);\n"
    "    return mat2(c, -s, s, c);\n"
    "}\n"
    "\n"
    "float hash(vec2 p) {\n"
    "    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n"
    "}\n"
    "\n"
    "vec4 getElectricGridColor() {\n"
    "    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n"
    "    float iTime = time * 0.35;\n"
    "    vec3 col = vec3(0.01, 0.02, 0.05);\n"
    "    uv *= rotate2D(iTime * 0.05);\n"
    "    uv *= (1.0 + 0.05 * sin(iTime * 0.2));\n"
    "    float grid_scale = 8.0;\n"
    "    vec2 grid_uv = uv * grid_scale;\n"
    "    grid_uv.x += iTime * 0.3;\n"
    "    grid_uv.y -= iTime * 0.2;\n"
    "    vec2 grid_id = floor(grid_uv);\n"
    "    vec2 grid_fract = fract(grid_uv);\n"
    "    float line_width = 0.03;\n"
    "    float line_intensity_x = smoothstep(line_width, 0.0, min(grid_fract.x, 1.0 - grid_fract.x));\n"
    "    float line_intensity_y = smoothstep(line_width, 0.0, min(grid_fract.y, 1.0 - grid_fract.y));\n"
    "    float grid_lines = max(line_intensity_x, line_intensity_y);\n"
    "    float pulse_wave = 0.6 + 0.4 * sin(grid_id.x * 0.7 - iTime * 2.5 + grid_id.y * 0.5);\n"
    "    grid_lines *= pulse_wave;\n"
    "    vec3 grid_color = vec3(0.1, 0.6, 1.0);\n"
    "    col = mix(col, grid_color, grid_lines * 0.7);\n"
    "    float dot_radius = 0.08;\n"
    "    float dist_to_center = length(grid_fract - 0.5);\n"
    "    float dots = smoothstep(dot_radius, dot_radius - 0.02, dist_to_center);\n"
    "    float dot_pulse = 0.5 + 0.5 * sin(hash(grid_id) * 6.283 + iTime * 4.0);\n"
    "    dots *= dot_pulse;\n"
    "    vec3 dot_color = vec3(0.8, 1.0, 1.0);\n"
    "    col = mix(col, dot_color, dots * 0.4);\n"
    "    vec2 fine_grid_uv = uv * grid_scale * 2.5;\n"
    "    fine_grid_uv.x -= iTime * 0.7;\n"
    "    fine_grid_uv.y += iTime * 0.5;\n"
    "    vec2 fine_grid_fract = fract(fine_grid_uv);\n"
    "    float fine_line_width = 0.01;\n"
    "    float fine_intensity_x = smoothstep(fine_line_width, 0.0, min(fine_grid_fract.x, 1.0 - fine_grid_fract.x));\n"
    "    float fine_intensity_y = smoothstep(fine_line_width, 0.0, min(fine_grid_fract.y, 1.0 - fine_grid_fract.y));\n"
    "    float fine_grid_lines = max(fine_intensity_x, fine_intensity_y);\n"
    "    col = mix(col, grid_color * 0.5, fine_grid_lines * 0.2);\n"
    "    return vec4(clamp(col, 0.0, 1.0), 0.8);\n"
    "}\n"
    "\n"
    "void main() {\n"
    "    float corner_radius_pixels = 40.0;\n"
    "    float borderGradient;\n"
    "    float corner_mask = roundedTopCornerMask(v_texcoord, corner_radius_pixels, borderGradient);\n"
    "    vec4 background_color = getElectricGridColor();\n"
    "    background_color.a *= corner_mask;\n"
    "    vec4 final_pixel_color = background_color;\n"
    "\n"
    "    // Apply border gradient\n"
    "    vec3 borderColor = vec3(0.2, 0.8, 1.0); // Cyan-ish gradient color\n"
    "    final_pixel_color.rgb = mix(final_pixel_color.rgb, borderColor, borderGradient * corner_mask);\n"
    "\n"
    "    if (u_isPreviewActive) {\n"
    "        bool is_inside_preview_x = (v_texcoord.x >= u_previewRect.x && v_texcoord.x < (u_previewRect.x + u_previewRect.z));\n"
    "        bool is_inside_preview_y = (v_texcoord.y >= u_previewRect.y && v_texcoord.y < (u_previewRect.y + u_previewRect.w));\n"
    "        \n"
    "        if (is_inside_preview_x && is_inside_preview_y) {\n"
    "            vec3 transformed_uv_homogeneous = u_previewTexTransform * vec3(v_texcoord, 1.0);\n"
    "            vec2 final_sample_uv = transformed_uv_homogeneous.xy;\n"
    "            vec4 preview_sample = texture(u_previewTexture, final_sample_uv);\n"
    "            \n"
    "            if (preview_sample.a > 0.05) {\n"
    "                final_pixel_color = mix(background_color, preview_sample, preview_sample.a);\n"
    "            }\n"
    "        }\n"
    "    }\n"
    "\n"
    "    frag_color = final_pixel_color.bgra;\n"
    "}";*/

//oil slick orginal
static const char *panel_fragment_shader_src =
    "#version 300 es\n"
    "precision mediump float;\n"
    "\n"
    "in vec2 v_texcoord; // Normalized UV for the panel quad itself (0,0 to 1,1)\n"
    "out vec4 frag_color;\n"
    "\n"
    "// Time and resolution uniforms for the background animation\n"
    "uniform float time;\n"
    "uniform vec2 iResolution; // Resolution of the viewport/target this shader draws to\n"
    "uniform vec2 panelDimensions; // Actual panel dimensions in pixels\n"
    "\n"
    "// Uniforms for the preview functionality\n"
    "uniform sampler2D u_previewTexture;     // The window texture for the preview\n"
    "uniform bool u_isPreviewActive;         // Flag: is there a preview to draw?\n"
    "uniform vec4 u_previewRect;           // Preview position and size on panel: x, y, w, h (normalized 0-1 relative to panel's own UVs)\n"
    "uniform mat3 u_previewTexTransform;   // Transform for sampling the preview texture\n"
    "\n"
    "// Oil fuel effect constants\n"
    "const float uMaxHeight = 1.0;\n"
    "const float uNoiseMag = 0.5;\n"
    "const float uA = 2.0;\n"
    "const float ETA = 1.4;\n"
    "const float LAMBDAMIN = 400.0;\n"
    "const float LAMBDAMAX = 600.0;\n"
    "\n"
    "// Function to calculate rounded top corner mask and border gradient using pixel-based dimensions\n"
    "float roundedTopCornerMask(vec2 uv, float radiusPixels, out float borderGradient) {\n"
    "    // Convert UV coordinates to pixel coordinates\n"
    "    vec2 pixelCoord = uv * panelDimensions;\n"
    "    \n"
    "    // Initialize border gradient (0.0 = no border, 1.0 = full border intensity)\n"
    "    borderGradient = 0.0;\n"
    "    float borderWidthPixels = 2.0; // Width of the border in pixels for straight edges\n"
    "    float smoothingFactor = 1.0; // Controls smoothness of border transition\n"
    "    \n"
    "    // Check the TOP of the panel (where pixelCoord.y is SMALLER than radiusPixels)\n"
    "    if (pixelCoord.y > radiusPixels) {\n"
    "        // Handle straight edges (left, right, bottom)\n"
    "        float distToLeft = pixelCoord.x;\n"
    "        float distToRight = panelDimensions.x - pixelCoord.x;\n"
    "        float distToBottom = panelDimensions.y - pixelCoord.y;\n"
    "        float minDistToEdge = min(min(distToLeft, distToRight), distToBottom);\n"
    "        if (minDistToEdge < borderWidthPixels) {\n"
    "            borderGradient = smoothstep(borderWidthPixels + smoothingFactor, borderWidthPixels - smoothingFactor, minDistToEdge);\n"
    "        }\n"
    "        return 1.0; // The non-rounded part is fully opaque\n"
    "    }\n"
    "    \n"
    "    // We are now in the top-most part of the panel. Check if we're in a corner.\n"
    "    vec2 corner_dist;\n"
    "    float mask = 1.0;\n"
    "    \n"
    "    // Top-left corner (pixelCoord.x is small)\n"
    "    if (pixelCoord.x < radiusPixels) {\n"
    "        corner_dist = vec2(radiusPixels - pixelCoord.x, radiusPixels - pixelCoord.y);\n"
    "        float dist_to_center = length(corner_dist);\n"
    "        mask = smoothstep(radiusPixels + 1.0, radiusPixels - 1.0, dist_to_center);\n"
    "        // Calculate smoother border gradient for the corner with halved thickness\n"
    "        float cornerBorderWidth = borderWidthPixels * 0.5; // Halve the border width for corners\n"
    "        float innerEdge = radiusPixels - cornerBorderWidth;\n"
    "        float outerEdge = radiusPixels + cornerBorderWidth;\n"
    "        if (dist_to_center <= outerEdge && dist_to_center >= innerEdge - smoothingFactor) {\n"
    "            borderGradient = smoothstep(outerEdge + smoothingFactor, innerEdge - smoothingFactor, dist_to_center);\n"
    "        }\n"
    "        return mask;\n"
    "    }\n"
    "    \n"
    "    // Top-right corner (pixelCoord.x is large)\n"
    "    if (pixelCoord.x > (panelDimensions.x - radiusPixels)) {\n"
    "        corner_dist = vec2(pixelCoord.x - (panelDimensions.x - radiusPixels), radiusPixels - pixelCoord.y);\n"
    "        float dist_to_center = length(corner_dist);\n"
    "        mask = smoothstep(radiusPixels + 1.0, radiusPixels - 1.0, dist_to_center);\n"
    "        // Calculate smoother border gradient for the corner with halved thickness\n"
    "        float cornerBorderWidth = borderWidthPixels * 0.5; // Halve the border width for corners\n"
    "        float innerEdge = radiusPixels - cornerBorderWidth;\n"
    "        float outerEdge = radiusPixels + cornerBorderWidth;\n"
    "        if (dist_to_center <= outerEdge && dist_to_center >= innerEdge - smoothingFactor) {\n"
    "            borderGradient = smoothstep(outerEdge + smoothingFactor, innerEdge - smoothingFactor, dist_to_center);\n"
    "        }\n"
    "        return mask;\n"
    "    }\n"
    "    \n"
    "    // The area between the corners at the top is fully opaque\n"
    "    // Check top edge for border\n"
    "    if (pixelCoord.y < borderWidthPixels) {\n"
    "        borderGradient = smoothstep(borderWidthPixels + smoothingFactor, borderWidthPixels - smoothingFactor, pixelCoord.y);\n"
    "    }\n"
    "    return 1.0;\n"
    "}\n"
    "\n"
    "// Simplex noise function\n"
    "vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n"
    "vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n"
    "vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\n"
    "vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n"
    "\n"
    "float snoise(vec3 v) {\n"
    "    const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n"
    "    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n"
    "\n"
    "    // First corner\n"
    "    vec3 i  = floor(v + dot(v, C.yyy));\n"
    "    vec3 x0 = v - i + dot(i, C.xxx);\n"
    "\n"
    "    // Other corners\n"
    "    vec3 g = step(x0.yzx, x0.xyz);\n"
    "    vec3 l = 1.0 - g;\n"
    "    vec3 i1 = min(g.xyz, l.zxy);\n"
    "    vec3 i2 = max(g.xyz, l.zxy);\n"
    "\n"
    "    vec3 x1 = x0 - i1 + C.xxx;\n"
    "    vec3 x2 = x0 - i2 + C.yyy;\n"
    "    vec3 x3 = x0 - D.yyy;\n"
    "\n"
    "    // Permutations\n"
    "    i = mod289(i);\n"
    "    vec4 p = permute(permute(permute(\n"
    "             i.z + vec4(0.0, i1.z, i2.z, 1.0))\n"
    "           + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n"
    "           + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n"
    "\n"
    "    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n"
    "    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n"
    "    float n_ = 0.142857142857; // 1.0/7.0\n"
    "    vec3  ns = n_ * D.wyz - D.xzx;\n"
    "\n"
    "    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n"
    "\n"
    "    vec4 x_ = floor(j * ns.z);\n"
    "    vec4 y_ = floor(j - 7.0 * x_);\n"
    "\n"
    "    vec4 x = x_ *ns.x + ns.yyyy;\n"
    "    vec4 y = y_ *ns.x + ns.yyyy;\n"
    "    vec4 h = 1.0 - abs(x) - abs(y);\n"
    "\n"
    "    vec4 b0 = vec4(x.xy, y.xy);\n"
    "    vec4 b1 = vec4(x.zw, y.zw);\n"
    "\n"
    "    vec4 s0 = floor(b0)*2.0 + 1.0;\n"
    "    vec4 s1 = floor(b1)*2.0 + 1.0;\n"
    "    vec4 sh = -step(h, vec4(0.0));\n"
    "\n"
    "    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n"
    "    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n"
    "\n"
    "    vec3 p0 = vec3(a0.xy,h.x);\n"
    "    vec3 p1 = vec3(a0.zw,h.y);\n"
    "    vec3 p2 = vec3(a1.xy,h.z);\n"
    "    vec3 p3 = vec3(a1.zw,h.w);\n"
    "\n"
    "    // Normalise gradients\n"
    "    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n"
    "    p0 *= norm.x;\n"
    "    p1 *= norm.y;\n"
    "    p2 *= norm.z;\n"
    "    p3 *= norm.w;\n"
    "\n"
    "    // Mix final noise value\n"
    "    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n"
    "    m = m * m;\n"
    "    return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n"
    "}\n"
    "\n"
    "// Rainbow function\n"
    "vec3 Rainbow(float t) {\n"
    "    vec3 c = 1.0 - pow(abs(vec3(t) - vec3(0.65, 0.5, 0.2)) * vec3(3.0, 3.0, 5.0), vec3(1.5));\n"
    "    return clamp(c, 0.0, 1.0);\n"
    "}\n"
    "\n"
    "vec3 AssignRGB(float lambda) {\n"
    "    float t = (lambda - LAMBDAMIN) / (LAMBDAMAX - LAMBDAMIN);\n"
    "    return Rainbow(clamp(t, 0.0, 1.0));\n"
    "}\n"
    "\n"
    "vec4 getOilFuelColor() {\n"
    "    // Use panel-relative UV coordinates scaled to match original behavior\n"
    "    vec2 uv = gl_FragCoord.xy/1000.0;\n"
    "    float noiseScale = 8.0; // Adjust this to change the noise scale\n"
    "    vec3 vMCposition = vec3(uv * noiseScale, time * 0.05);\n"
    "\n"
    "    float nv = snoise(vMCposition);\n"
    "\n"
    "    float rad = distance(uv, vec2(0.5)) + uNoiseMag * (nv - 0.5);\n"
    "\n"
    "    float d = uMaxHeight * (0.5 + 0.5 * nv);\n"
    "\n"
    "    vec3 color = vec3(0.0);\n"
    "    int count = 0;\n"
    "\n"
    "    for (int m = 1; m <= 10; m++) {\n"
    "       float lambda = 900.0 * d * ETA / (float(m) + 0.1);\n"
    "       color += AssignRGB(lambda);\n"
    "       color += AssignRGB(lambda);\n"
    "       color += AssignRGB(lambda);\n"
    "       color += AssignRGB(lambda);\n"
    "       color += AssignRGB(lambda);\n"
    "       color += AssignRGB(lambda);\n"
    "       color += AssignRGB(lambda);\n"
    "       color += AssignRGB(lambda);\n"
    "       count++;\n"
    "    }\n"
    "\n"
    "    return vec4(color / float(count-5), 0.9);\n"
    "}\n"
    "\n"
    "void main() {\n"
    "    float corner_radius_pixels = 40.0;\n"
    "    float borderGradient;\n"
    "    float corner_mask = roundedTopCornerMask(v_texcoord, corner_radius_pixels, borderGradient);\n"
    "    vec4 background_color = getOilFuelColor();\n"
    "    background_color.a *= corner_mask;\n"
    "    vec4 final_pixel_color = background_color;\n"
    "\n"
    "    // Apply border gradient with a color that complements the oil fuel effect\n"
    "    vec3 borderColor = vec3(0.0, 0.0, 1.0); // Purple-ish gradient color to complement the rainbow\n"
    "    final_pixel_color.rgb = mix(final_pixel_color.rgb, borderColor, borderGradient * corner_mask);\n"
    "\n"
    "    if (u_isPreviewActive) {\n"
    "        bool is_inside_preview_x = (v_texcoord.x >= u_previewRect.x && v_texcoord.x < (u_previewRect.x + u_previewRect.z));\n"
    "        bool is_inside_preview_y = (v_texcoord.y >= u_previewRect.y && v_texcoord.y < (u_previewRect.y + u_previewRect.w));\n"
    "        \n"
    "        if (is_inside_preview_x && is_inside_preview_y) {\n"
    "            vec3 transformed_uv_homogeneous = u_previewTexTransform * vec3(v_texcoord, 1.0);\n"
    "            vec2 final_sample_uv = transformed_uv_homogeneous.xy;\n"
    "            vec4 preview_sample = texture(u_previewTexture, final_sample_uv);\n"
    "            \n"
    "            if (preview_sample.a > 0.05) {\n"
    "                final_pixel_color = mix(background_color, preview_sample, preview_sample.a);\n"
    "            }\n"
    "        }\n"
    "    }\n"
    "\n"
    "    frag_color = final_pixel_color.bgra;\n"
    "}";
const char *back_vertex_shader_src =
        "#version 300 es\n"
    "precision mediump float;\n"
    "layout(location = 0) in vec2 position;\n"    // Position at location 0
    "layout(location = 1) in vec2 texcoord;\n"    // Texcoord at location 1
    "out vec2 v_texcoord;\n"
    "uniform mat3 mvp;\n"
    "void main() {\n"
    "    vec3 pos_transformed = mvp * vec3(position, 1.0);\n"
    "    gl_Position = vec4(pos_transformed.xy, 0.0, 1.0);\n"
    "    v_texcoord = texcoord;\n"
    "}\n";

const char *back_fragment_shader_src =   
    "/* Octgrams shader converted to panel format, with curved corners using v_texcoord */\n"
    "#version 300 es\n"
    "precision mediump float;\n"
    "\n"
    "in vec2 v_texcoord; // IMPORTANT: This MUST be correctly supplied for the panel's quad\n"
    "out vec4 frag_color;\n"
    "\n"
    "uniform float time;\n"
    "uniform vec2 iResolution; // Resolution of the viewport/target this shader draws to\n"
    "\n"
    "float gTime = 0.0;\n"
    "const float REPEAT = 5.0;\n"
    "\n"
    "mat2 rot(float a) {\n"
    "    float c = cos(a), s = sin(a);\n"
    "    return mat2(c,s,-s,c);\n"
    "}\n"
    "\n"
    "float sdBox( vec3 p, vec3 b ) {\n"
    "    vec3 q = abs(p) - b;\n"
    "    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n"
    "}\n"
    "\n"
    "// Helper function for Signed Distance to a 2D Rounded Box\n"
    "// p: point to sample in pixel coordinates\n"
    "// b: half-extents of the box in pixel coordinates\n"
    "// r: corner radius in pixels (constant regardless of aspect ratio)\n"
    "float sdfRoundBox2D(vec2 p, vec2 b, float r) {\n"
    "    r = min(r, min(b.x, b.y)); // Clamp radius\n"
    "    vec2 q = abs(p) - b + r;\n"
    "    return min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r;\n"
    "}\n"
    "\n"
    "float box(vec3 pos, float scale) {\n"
    "    pos *= scale;\n"
    "    float base = sdBox(pos, vec3(.4,.4,.1)) /1.5;\n"
    "    pos.xy *= 5.0;\n"
    "    pos.y -= 3.5;\n"
    "    pos.xy *= rot(.75);\n"
    "    float result = -base;\n"
    "    return result;\n"
    "}\n"
    "\n"
    "float box_set(vec3 pos, float iTime) {\n"
    "    vec3 pos_origin = pos;\n"
    "    pos = pos_origin;\n"
    "    pos.y += sin(gTime * 0.4) * 2.5;\n"
    "    pos.xy *= rot(.8);\n"
    "    float box1 = box(pos,2.0 - abs(sin(gTime * 0.4)) * 1.5);\n"
    "    pos = pos_origin;\n"
    "    pos.y -=sin(gTime * 0.4) * 2.5;\n"
    "    pos.xy *= rot(.8);\n"
    "    float box2 = box(pos,2.0 - abs(sin(gTime * 0.4)) * 1.5);\n"
    "    pos = pos_origin;\n"
    "    pos.x +=sin(gTime * 0.4) * 2.5;\n"
    "    pos.xy *= rot(.8);\n"
    "    float box3 = box(pos,2.0 - abs(sin(gTime * 0.4)) * 1.5);\n"
    "    pos = pos_origin;\n"
    "    pos.x -=sin(gTime * 0.4) * 2.5;\n"
    "    pos.xy *= rot(.8);\n"
    "    float box4 = box(pos,2.0 - abs(sin(gTime * 0.4)) * 1.5);\n"
    "    pos = pos_origin;\n"
    "    pos.xy *= rot(.8);\n"
    "    float box5 = box(pos,.5) * 6.0;\n"
    "    pos = pos_origin;\n"
    "    float box6 = box(pos,.5) * 6.0;\n"
    "    float result = max(max(max(max(max(box1,box2),box3),box4),box5),box6);\n"
    "    return result;\n"
    "}\n"
    "\n"
    "float map(vec3 pos, float iTime) {\n"
    "    vec3 pos_origin = pos;\n"
    "    float box_set1 = box_set(pos, iTime);\n"
    "    return box_set1;\n"
    "}\n"
    "\n"
    "void main() {\n"
    "    // Scene rendering part (uses gl_FragCoord to map to the effect space)\n"
    "    vec2 fragCoord_for_scene = gl_FragCoord.xy;\n"
    "    float iTime = time;\n"
    "    \n"
    "    vec2 p_scene = (fragCoord_for_scene * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n"
    "    vec3 ro = vec3(0.0, -0.2, iTime * 4.0);\n"
    "    vec3 ray = normalize(vec3(p_scene, 1.5));\n"
    "    ray.xy = ray.xy * rot(sin(iTime * .03) * 5.0);\n"
    "    ray.yz = ray.yz * rot(sin(iTime * .05) * .2);\n"
    "    float t = 0.1;\n"
    "    vec3 col = vec3(0.0);\n"
    "    float ac = 0.0;\n"
    "    \n"
    "    for (int i = 0; i < 99; i++){\n"
    "        vec3 pos = ro + ray * t;\n"
    "        pos = mod(pos-2.0, 4.0) -2.0;\n"
    "        gTime = iTime -float(i) * 0.01;\n"
    "        \n"
    "        float d = map(pos, iTime);\n"
    "        d = max(abs(d), 0.01);\n"
    "        ac += exp(-d*23.0);\n"
    "        t += d* 0.55;\n"
    "    }\n"
    "    \n"
    "    col = vec3(ac * 0.02);\n"
    "    col +=vec3(0.0,0.2 * abs(sin(iTime)),0.5 + sin(iTime) * 0.2);\n"
    "    \n"
    "    // --- Rounded Corners Masking using pixel-perfect dimensions ---\n"
    "    // Convert v_texcoord [0,1] to pixel coordinates relative to center\n"
    "    vec2 pixel_pos = (v_texcoord - 0.5) * iResolution;\n"
    "\n"
    "    // Half-extents of the rectangle in pixels\n"
    "    vec2 box_half_extents_pixels = iResolution * 0.5;\n"
    "    \n"
    "    // Corner radius in pixels (constant circular radius regardless of aspect ratio)\n"
    "    float corner_radius_pixels = 20.0; // Adjust this value for desired corner size\n"
    "\n"
    "    // Calculate signed distance to the rounded rectangle edge in pixels\n"
    "    float dist_to_edge = sdfRoundBox2D(pixel_pos, box_half_extents_pixels, corner_radius_pixels);\n"
    "\n"
    "    // Antialiasing width in pixels (typically 1-2 pixels for smooth edges)\n"
    "    float aa_pixels = 1.5;\n"
    "    \n"
    "    // Create alpha mask: 1.0 inside, 0.0 outside, smooth transition at the edge\n"
    "    // Using step function to ensure corners are completely transparent\n"
    "    float shape_alpha_mask;\n"
    "    if (dist_to_edge > aa_pixels * 0.5) {\n"
    "        shape_alpha_mask = 0.0; // Completely outside - fully transparent\n"
    "    } else if (dist_to_edge < -aa_pixels * 0.5) {\n"
    "        shape_alpha_mask = 1.0; // Completely inside - fully opaque\n"
    "    } else {\n"
    "        // Smooth transition zone\n"
    "        shape_alpha_mask = 1.0 - smoothstep(-aa_pixels * 0.5, aa_pixels * 0.5, dist_to_edge);\n"
    "    }\n"
    "    \n"
    "    shape_alpha_mask = clamp(shape_alpha_mask, 0.0, 1.0);\n"
    "\n"
    "    float original_alpha = 0.6; // Original alpha of the content\n"
    "    float final_alpha = original_alpha * shape_alpha_mask;\n"
    "    // --- End Rounded Corners Masking ---\n"
    "\n"
    "    frag_color = vec4(col, final_alpha).bgra;\n"
    "}";

static const char *ssd_vertex_shader_src =
       "#version 300 es\n"
    "precision mediump float;\n"
    "layout(location = 0) in vec2 position;\n"    // Position at location 0
    "layout(location = 1) in vec2 texcoord;\n"    // Texcoord at location 1
    "out vec2 v_texcoord;\n"
    "uniform mat3 mvp;\n"
    "void main() {\n"
    "    vec3 pos_transformed = mvp * vec3(position, 1.0);\n"
    "    gl_Position = vec4(pos_transformed.xy, 0.0, 1.0);\n"
    "    v_texcoord = texcoord;\n"
    "}\n";

//army
/*
static const char *ssd2_fragment_shader_src =
    "#version 300 es\n"
    "precision mediump float;\n"
    "\n"
    "in vec2 v_texcoord; // IMPORTANT: This MUST be correctly supplied for the panel's quad\n"
    "out vec4 frag_color;\n"
    "\n"
    "uniform float time;\n"
    "uniform vec2 iResolution; // Resolution of the viewport/target this shader draws to\n"
    "\n"
    "// --- Start of Inigo Quilez's shader code (adapted) ---\n"
    "// Copyright Inigo Quilez, 2013 - https://iquilezles.org/\n"
    "// I am the sole copyright owner of this Work.\n"
    "// You cannot host, display, distribute or share this Work neither\n"
    "// as it is or altered, here on Shadertoy or anywhere else, in any\n"
    "// form including physical and digital. You cannot use this Work in any\n"
    "// commercial or non-commercial product, website or project. You cannot\n"
    "// sell this Work and you cannot mint an NFTs of it or train a neural\n"
    "// network with it without permission. I share this Work for educational\n"
    "// purposes, and you can link to it, through an URL, proper attribution\n"
    "// and unmodified screenshot, as part of your educational material. If\n"
    "// these conditions are too restrictive please contact me and we'll\n"
    "// definitely work it out.\n"
    "\n"
    "// See here for a tutorial on how to make this:\n"
    "//\n"
    "// https://iquilezles.org/articles/warp\n"
    "\n"
    "//====================================================================\n"
    "\n"
    "const mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n"
    "\n"
    "float noise( in vec2 p )\n"
    "{\n"
    "   return sin(p.x)*sin(p.y);\n"
    "}\n"
    "\n"
    "float fbm4( vec2 p )\n"
    "{\n"
    "    float f = 0.0;\n"
    "    f += 0.5000*noise( p ); p = m*p*2.02;\n"
    "    f += 0.2500*noise( p ); p = m*p*2.03;\n"
    "    f += 0.1250*noise( p ); p = m*p*2.01;\n"
    "    f += 0.0625*noise( p );\n"
    "    return f/0.9375;\n"
    "}\n"
    "\n"
    "float fbm6( vec2 p )\n"
    "{\n"
    "    float f = 0.0;\n"
    "    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\n"
    "    f += 0.250000*(0.5+0.5*noise( p )); p = m*p*2.03;\n"
    "    f += 0.125000*(0.5+0.5*noise( p )); p = m*p*2.01;\n"
    "    f += 0.062500*(0.5+0.5*noise( p )); p = m*p*2.04;\n"
    "    f += 0.031250*(0.5+0.5*noise( p )); p = m*p*2.01;\n"
    "    f += 0.015625*(0.5+0.5*noise( p ));\n"
    "    return f/0.96875;\n"
    "}\n"
    "\n"
    "vec2 fbm4_2( vec2 p )\n"
    "{\n"
    "    return vec2(fbm4(p), fbm4(p+vec2(7.8)));\n"
    "}\n"
    "\n"
    "vec2 fbm6_2( vec2 p )\n"
    "{\n"
    "    return vec2(fbm6(p+vec2(16.8)), fbm6(p+vec2(11.5)));\n"
    "}\n"
    "\n"
    "//====================================================================\n"
    "\n"
    "// Input 'time' (original uniform) is used instead of 'iTime' from Shadertoy\n"
    "float func( vec2 q, out vec4 ron )\n"
    "{\n"
    "    q += 0.03*sin( vec2(0.27,0.23)*time*10.0 + length(q)*vec2(4.1,4.3));\n"
    "\n"
    "   vec2 o = fbm4_2( 0.9*q );\n"
    "\n"
    "    o += 0.04*sin( vec2(0.12,0.14)*time*10.0 + length(o));\n"
    "\n"
    "    vec2 n = fbm6_2( 3.0*o );\n"
    "\n"
    "   ron = vec4( o, n );\n"
    "\n"
    "    float f = 0.5 + 0.5*fbm4( 1.8*q + 6.0*n );\n"
    "\n"
    "    return mix( f, f*f*f*3.5, f*abs(n.x) );\n"
    "}\n"
    "\n"
    "// Helper function for Signed Distance to a 2D Box with individual corner control\n"
    "// p: point to sample in pixel coordinates\n"
    "// b: half-extents of the box in pixel coordinates\n"
    "// r: corner radius in pixels\n"
    "float sdfTopRoundBox2D(vec2 p, vec2 b, float r) {\n"
    "    r = min(r, min(b.x, b.y)); // Clamp radius to prevent issues with small rectangles\n"
    "    \n"
    "    // **Top Left**: roundTopLeft = false (SHARP)\n"
    "    // **Top Right**: roundTopRight = false (SHARP)\n"
    "    // **Bottom Left**: roundBottomLeft = true (ROUNDED)\n"
    "    // **Bottom Right**: roundBottomRight = true (ROUNDED)\n"
    "    bool roundTopLeft = false;\n"
    "    bool roundTopRight = false;\n"
    "    bool roundBottomLeft = true;\n"
    "    bool roundBottomRight = true;\n"
    "    \n"
    "    // Determine which corner we're in\n"
    "    bool inTopLeft = (p.x < -b.x + r && p.y > b.y - r);\n"
    "    bool inTopRight = (p.x > b.x - r && p.y > b.y - r);\n"
    "    bool inBottomLeft = (p.x < -b.x + r && p.y < -b.y + r);\n"
    "    bool inBottomRight = (p.x > b.x - r && p.y < -b.y + r);\n"
    "    \n"
    "    // Apply rounding to specific corners\n"
    "    if (inTopLeft && roundTopLeft) {\n"
    "        vec2 corner_center = vec2(-b.x + r, b.y - r);\n"
    "        return length(p - corner_center) - r;\n"
    "    }\n"
    "    else if (inTopRight && roundTopRight) {\n"
    "        vec2 corner_center = vec2(b.x - r, b.y - r);\n"
    "        return length(p - corner_center) - r;\n"
    "    }\n"
    "    else if (inBottomLeft && roundBottomLeft) {\n"
    "        vec2 corner_center = vec2(-b.x + r, -b.y + r);\n"
    "        return length(p - corner_center) - r;\n"
    "    }\n"
    "    else if (inBottomRight && roundBottomRight) {\n"
    "        vec2 corner_center = vec2(b.x - r, -b.y + r);\n"
    "        return length(p - corner_center) - r;\n"
    "    }\n"
    "    \n"
    "    // Default to regular box SDF for all other areas\n"
    "    vec2 q = abs(p) - b;\n"
    "    return max(q.x, q.y);\n"
    "}\n"
    "\n"
    "void main() {\n"
    "    // Scene rendering part (uses v_texcoord to keep effect fixed to panel)\n"
    "    vec2 fragCoord_for_scene = v_texcoord * iResolution;\n"
    "    float iTime = time*200.0;\n"
    "    \n"
    "    // Calculate normalized coordinates 'p' using v_texcoord instead of gl_FragCoord\n"
    "    // This keeps the effect fixed to the panel regardless of window position\n"
    "    vec2 p = (2.0*fragCoord_for_scene - iResolution.xy) / iResolution.y;\n"
    "    float e = 2.0 / iResolution.y; // Small epsilon for derivatives, based on resolution\n"
    "\n"
    "    vec4 on = vec4(0.0); // Will store intermediate values 'o' and 'n' from func\n"
    "    float f = func(p, on); // Call the main pattern generation function\n"
    "\n"
    "   vec3 col = vec3(0.0);\n"
    "    col = mix( vec3(0.2,0.1,0.4), vec3(0.3,0.05,0.05), f );\n"
    "    col = mix( col, vec3(0.9,0.9,0.9), dot(on.zw,on.zw) ); // on.zw corresponds to 'n'\n"
    "    col = mix( col, vec3(0.0,0.0,0.9), 0.2 + 0.5*on.y*on.y ); // on.y corresponds to 'o.y'\n"
    "    col = mix( col, vec3(0.9,0.2,0.2), 0.5*smoothstep(1.2,1.3,abs(on.z)+abs(on.w)) ); // on.z, on.w are n.x, n.y\n"
    "    col = clamp( col*f*2.0, 0.0, 1.0 );\n"
    "    \n"
    "#if 0\n"
    "    // GPU derivatives - bad quality, but fast\n"
    "    // Uses iResolution.x and iResolution.y for scaling derivatives\n"
    "   vec3 nor = normalize( vec3( dFdx(f)*iResolution.x*10.0, 6.0, dFdy(f)*iResolution.y*10.0 ) );\n"
    "#else\n"
    "    // Manual derivatives - better quality, but slower\n"
    "    vec4 kk; // Dummy 'out' variable for func calls\n"
    "   vec3 nor = normalize( vec3( func(p+vec2(e,0.0),kk)-f, \n"
    "                                2.0*e, \n"
    "                                func(p+vec2(0.0,e),kk)-f ) );\n"
    "#endif\n"
    "\n"
    "    vec3 lig = normalize( vec3( 0.9, 0.2, -0.4 ) );\n"
    "    float dif = clamp( 0.3+0.7*dot( nor, lig ), 0.0, 1.0 );\n"
    "    vec3 lin = vec3(0.70,0.90,0.95)*(nor.y*0.5+0.5) + vec3(0.15,0.10,0.05)*dif;\n"
    "    col *= 1.2*lin;\n"
    "   col = 1.0 - col; // Invert colors\n"
    "   col = 1.1*col*col; // Apply contrast/gamma like effect\n"
    "    \n"
    "    // --- Individual Corner Control Rounded Masking with FIXED 40px corner radius ---\n"
    "    // Convert v_texcoord [0,1] to actual pixel coordinates from center\n"
    "    // This ensures the coordinate system matches the actual pixel dimensions\n"
    "    vec2 pixel_pos = (v_texcoord - 0.5) * iResolution;\n"
    "\n"
    "    // Half-extents of the rectangle in pixels\n"
    "    vec2 box_half_extents_pixels = iResolution * 0.5;\n"
    "    \n"
    "    // FIXED corner radius in pixels - this will always be 40 pixels regardless of shape size\n"
    "    float corner_radius_pixels = 40.0;\n"
    "\n"
    "    // Calculate signed distance to the selectively-rounded rectangle edge in pixels\n"
    "    float dist_to_edge = sdfTopRoundBox2D(pixel_pos, box_half_extents_pixels, corner_radius_pixels);\n"
    "\n"
    "    // Antialiasing width in pixels (using 2.0 for smoother edges with larger radius)\n"
    "    float aa_pixels = 2.0;\n"
    "    \n"
    "    // Create alpha mask: 1.0 inside, 0.0 outside, smooth transition at the edge\n"
    "    float shape_alpha_mask;\n"
    "    if (dist_to_edge > aa_pixels * 0.5) {\n"
    "        shape_alpha_mask = 0.0; // Completely outside - fully transparent\n"
    "    } else if (dist_to_edge < -aa_pixels * 0.5) {\n"
    "        shape_alpha_mask = 1.0; // Completely inside - fully opaque\n"
    "    } else {\n"
    "        // Smooth transition zone\n"
    "        shape_alpha_mask = 1.0 - smoothstep(-aa_pixels * 0.5, aa_pixels * 0.5, dist_to_edge);\n"
    "    }\n"
    "    \n"
    "    shape_alpha_mask = clamp(shape_alpha_mask, 0.0, 1.0);\n"
    "\n"
    "    float original_alpha = 0.9; // Original alpha of the content\n"
    "    float final_alpha = original_alpha * shape_alpha_mask;\n"
    "    // --- End Individual Corner Control Rounded Masking ---\n"
    "\n"
    "    frag_color = vec4(col, final_alpha*0.8).bgra;\n"
    "}\n"
    "// --- End of Inigo Quilez's shader code (adapted) ---\n";*/

// NEW: Converted ssd2 shader with rounded corners and cycling gradient bevel.
// NEW: SSD shader for a translucent, color-matched fill with a cycling gradient border.
// NEW: SSD shader for a translucent fill with a HORIZONTAL cycling gradient border.
static const char *ssd2_fragment_shader_src =
    "#version 300 es\n"
    "precision highp float;\n"
    "\n"
    "in vec2 v_texcoord;\n"
    "out vec4 frag_color;\n"
    "\n"
    "uniform float time;\n"
    "uniform vec2 iResolution; // Resolution of the rect being drawn\n"
    "\n"
    "// --- Effect Parameters ---\n"
    "const float cornerRadius = 40.0;\n"
    "const float borderWidth = 4.0;\n"
    "const float aa = 1.5;\n"
    "\n"
    "// --- Helper functions (unchanged) ---\n"
    "float sdRoundedBox(vec2 p, vec2 b, float r) {\n"
    "    vec2 q = abs(p) - b + r;\n"
    "    return min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r;\n"
    "}\n"
    "\n"
    "vec3 hsv2rgb(vec3 c) {\n"
    "    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n"
    "    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n"
    "    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n"
    "}\n"
    "\n"
    "void main() {\n"
    "    // --- 1. Shape Calculation (unchanged) ---\n"
    "    vec2 p = (v_texcoord - 0.5) * iResolution;\n"
    "    float d = sdRoundedBox(p, iResolution * 0.5, cornerRadius);\n"
    "\n"
    "    // =========================================================\n"
    "    // --- 2. NEW: Horizontal Gradient Color Calculation ---\n"
    "    // =========================================================\n"
    "    // Instead of using an angle, we use the horizontal texture coordinate.\n"
    "    // v_texcoord.x ranges from 0.0 on the left to 1.0 on the right.\n"
    "    float hue_base = v_texcoord.x;\n"
    "\n"
    "    // Animate the hue by shifting it over time. The fract() makes it loop.\n"
    "    float hue = fract(hue_base - time * 0.15);\n"
    "\n"
    "    // Create the two colors from the same hue, but with different saturation/brightness.\n"
    "    vec3 border_color = hsv2rgb(vec3(hue, 0.9, 1.0)); // Bright, saturated border\n"
    "    vec3 fill_color   = hsv2rgb(vec3(hue, 0.8, 0.5)); // Dimmer, less saturated fill\n"
    "\n"
    "    // --- 3. Final Composition (unchanged) ---\n"
    "    float border_mix = smoothstep(-borderWidth, -borderWidth + aa, d);\n"
    "    vec3 final_rgb = mix(border_color, fill_color, border_mix);\n"
    "\n"
    "    float border_alpha = 0.95;\n"
    "    float fill_alpha = 0.0;\n"
    "    float final_alpha = mix(border_alpha, fill_alpha, border_mix);\n"
    "\n"
    "    final_alpha *= (1.0 - smoothstep(-aa, aa, d));\n"
    "\n"
    "    frag_color = vec4(final_rgb, final_alpha).bgra;\n"
    "}\n";

/*
static const char *ssd_fragment_shader_src =
  "// Seigaiha Mandala shader converted to panel format, with curved corners using v_texcoord \n"
    "#version 300 es\n"
    "precision mediump float;\n"
    "\n"
    "in vec2 v_texcoord;\n"
    "out vec4 frag_color;\n"
    "\n"
    "uniform float time;\n"
    "uniform vec2 iResolution;\n"
    "\n"
    "// --- Start of Seigaiha Mandala shader code (adapted) ---\n"
    "// Seigaiha Mandala by Philippe Desgranges\n"
    "// Email: Philippe.desgranges@gmail.com\n"
    "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n"
    "\n"
    "#define S(a,b,c) smoothstep(a,b,c)\n"
    "\n"
    "vec3 premulMix(vec4 src, vec3 dst) {\n"
    "    return dst.rgb * (1.0 - src.a) + src.rgb;\n"
    "}\n"
    "\n"
    "vec4 premulMix(vec4 src, vec4 dst) {\n"
    "    vec4 res;\n"
    "    res.rgb = premulMix(src, dst.rgb);\n"
    "    res.a = 1.0 - (1.0 - src.a) * (1.0 - dst.a);\n"
    "    return res;\n"
    "}\n"
    "\n"
    "vec4 roundPattern(vec2 uv, vec2 resolution) {\n"
    "    float dist = length(uv);\n"
    "    float aa = 0.02;\n"
    "    float triangle = abs(fract(dist * 11.0 + 0.3) - 0.5);\n"
    "    float circles = S(0.25 - aa, 0.25 + aa, triangle);\n"
    "    float grad = dist * 2.0;\n"
    "    vec3 col = mix(vec3(0.0, 0.5, 0.6),  vec3(0.0, 0.2, 0.5), grad * grad);\n"
    "    col = mix(col, vec3(1.0), circles);\n"
    "    vec3 borderColor = vec3(0.7, 0.2, 0.2);\n"
    "    col = mix(col, borderColor, S(0.44 - aa, 0.44 + aa, dist));\n"
    "    col = mix(col, borderColor, S(0.05 + aa, 0.05 - aa, dist));\n"
    "    float mask = S(0.5, 0.49, dist);\n"
    "    return vec4(col * mask, mask);\n"
    "}\n"
    "\n"
    "vec4 ring(vec2 uv, float angle, float angleOffet, float centerDist, float numcircles, float circlesRad, vec2 resolution) {\n"
    "    float quadId = floor(angle * numcircles + angleOffet);\n"
    "    float quadAngle = (quadId + 0.5 - angleOffet) * (6.283 / numcircles);\n"
    "    vec2 quadCenter = vec2(cos(quadAngle), sin(quadAngle)) * centerDist;\n"
    "    vec2 circleUv = (uv + quadCenter) / circlesRad;\n"
    "    return roundPattern(circleUv, resolution);\n"
    "}\n"
    "\n"
    "vec4 dblRing(vec2 uv, float angle, float centerDist, float numcircles, float circlesRad, float t, vec2 resolution) {\n"
    "    float s = sin(t * 3.0 + centerDist * 10.0) * 0.05;\n"
    "    float d1 = 1.05 + s;\n"
    "    float d2 = 1.05 - s;\n"
    "    float rot = t * centerDist * 0.4 + sin(t + centerDist * 5.0) * 0.2;\n"
    "    vec4 ring1 = ring(uv, angle, 0.0 + rot, centerDist * d1, numcircles, circlesRad, resolution);\n"
    "    vec4 ring2 = ring(uv, angle, 0.5 + rot, centerDist * d2, numcircles, circlesRad, resolution);\n"
    "    vec4 col = premulMix(ring1, ring2);\n"
    "    return col;\n"
    "}\n"
    "\n"
    "vec4 autoRing(vec2 uv, float angle, float centerDist, float t, vec2 resolution) {\n"
    "    float nbCircles = 1.0 + floor(centerDist * 23.0);\n"
    "    return dblRing(uv, angle, centerDist, nbCircles, 0.23, t, resolution);\n"
    "}\n"
    "\n"
    "vec3 fullImage(vec2 uv, float angle, float centerDist, float t, vec2 resolution) {\n"
    "    vec3 col;\n"
    "    float space = 0.1;\n"
    "    float ringRad = floor(centerDist / space) * space;\n"
    "    vec4 ringCol1 = autoRing(uv, angle, ringRad - space, t, resolution);\n"
    "    vec4 ringCol2 = autoRing(uv, angle, ringRad, t, resolution);\n"
    "    vec4 ringCol3 = autoRing(uv, angle, ringRad + space, t, resolution);\n"
    "    if (ringRad > 0.0) {\n"
    "        col.rgb = ringCol3.rgb;\n"
    "        col.rgb = premulMix(ringCol2, col.rgb);\n"
    "        col.rgb = premulMix(ringCol1, col.rgb);\n"
    "    } else {\n"
    "        col.rgb = ringCol2.rgb;\n"
    "    }\n"
    "    return col;\n"
    "}\n"
    "\n"
    "float sdfTopRoundBox2D(vec2 p, vec2 b, float r) {\n"
    "    r = min(r, min(b.x, b.y));\n"
    "    bool roundTopLeft = false;\n"
    "    bool roundTopRight = false;\n"
    "    bool roundBottomLeft = true;\n"
    "    bool roundBottomRight = true;\n"
    "    bool inTopLeft = (p.x < -b.x + r && p.y > b.y - r);\n"
    "    bool inTopRight = (p.x > b.x - r && p.y > b.y - r);\n"
    "    bool inBottomLeft = (p.x < -b.x + r && p.y < -b.y + r);\n"
    "    bool inBottomRight = (p.x > b.x - r && p.y < -b.y + r);\n"
    "    if (inTopLeft && roundTopLeft) {\n"
    "        vec2 corner_center = vec2(-b.x + r, b.y - r);\n"
    "        return length(p - corner_center) - r;\n"
    "    } else if (inTopRight && roundTopRight) {\n"
    "        vec2 corner_center = vec2(b.x - r, b.y - r);\n"
    "        return length(p - corner_center) - r;\n"
    "    } else if (inBottomLeft && roundBottomLeft) {\n"
    "        vec2 corner_center = vec2(-b.x + r, -b.y + r);\n"
    "        return length(p - corner_center) - r;\n"
    "    } else if (inBottomRight && roundBottomRight) {\n"
    "        vec2 corner_center = vec2(b.x - r, -b.y + r);\n"
    "        return length(p - corner_center) - r;\n"
    "    }\n"
    "    vec2 q = abs(p) - b;\n"
    "    return max(q.x, q.y);\n"
    "}\n"
    "\n"
    "void main() {\n"
    "    vec2 fragCoord = v_texcoord * iResolution;\n"
    "    float iTime = time;\n"
    "\n"
    "    // --- DEFINE PATTERN SCALE HERE ---\n"
    "    // This value now controls the size. It is independent of the panel's resolution.\n"
    "    // SMALLER number = LARGER pattern (zoomed in).\n"
    "    // LARGER number = SMALLER pattern (zoomed out).\n"
    "    float patternScale = 800.0; // <-- EDIT THIS VALUE TO CHANGE SIZE\n"
    "\n"
    "    // Calculate pattern coordinates using the fixed scale\n"
    "    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / patternScale;\n"
    "uv *= 4.0; "
    "\n"
    "    // Computes polar coordinates for the pattern\n"
    "    float angle = atan(uv.y, uv.x) / 6.283 + 0.5;\n"
    "    float centerDist = length(uv);\n"
    "\n"
    "    // Generate the pattern color\n"
    "    vec3 col = fullImage(uv, angle, centerDist, iTime, iResolution);\n"
    "\n"
    "    // --- MASKING logic (remains the same) ---\n"
    "    vec2 pixel_pos = (v_texcoord - 0.5) * iResolution;\n"
    "    vec2 box_half_extents_pixels = iResolution * 0.5;\n"
    "    float corner_radius_pixels = 40.0;\n"
    "    float dist_to_edge = sdfTopRoundBox2D(pixel_pos, box_half_extents_pixels, corner_radius_pixels);\n"
    "    float aa_pixels = 2.0;\n"
    "    \n"
    "    float shape_alpha_mask;\n"
    "    if (dist_to_edge > aa_pixels * 0.5) {\n"
    "        shape_alpha_mask = 0.0;\n"
    "    } else if (dist_to_edge < -aa_pixels * 0.5) {\n"
    "        shape_alpha_mask = 1.0;\n"
    "    } else {\n"
    "        shape_alpha_mask = 1.0 - smoothstep(-aa_pixels * 0.5, aa_pixels * 0.5, dist_to_edge);\n"
    "    }\n"
    "    shape_alpha_mask = clamp(shape_alpha_mask, 0.0, 1.0);\n"
    "    float final_alpha = 1.0 * shape_alpha_mask;\n"
    "\n"
    "    frag_color = vec4(col, final_alpha).bgra;\n"
    "}\n"
    "// --- End of Seigaiha Mandala shader ---";*/

//https://www.shadertoy.com/view/wlscWX

/*
static const char *ssd_fragment_shader_src =

  "\n"
    "#version 300 es\n"
    "precision mediump float;\n"
    "\n"
    "in vec2 v_texcoord;\n"
    "out vec4 frag_color;\n"
    "\n"
    "uniform float time;\n"
    "uniform vec2 iResolution;\n"
    "\n"
    "#define OFFSET_ROW\n"
    "\n"
    "// --- Start of Pyramid Pattern Helper Functions ---\n"
    "mat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n"
    "\n"
    "float hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n"
    "\n"
    "vec2 hash22B(vec2 p) {\n"
    "    float n = sin(dot(p, vec2(41, 289)));\n"
    "    return fract(vec2(262144, 32768)*n)*2. - 1.;\n"
    "}\n"
    "\n"
    "float n2D3G( in vec2 p ){\n"
    "    vec2 i = floor(p); p -= i;\n"
    "    vec4 v;\n"
    "    v.x = dot(hash22B(i), p);\n"
    "    v.y = dot(hash22B(i + vec2(1, 0)), p - vec2(1, 0));\n"
    "    v.z = dot(hash22B(i + vec2(0, 1)), p - vec2(0, 1));\n"
    "    v.w = dot(hash22B(i + 1.), p - 1.);\n"
    "    p = p*p*(3. - 2.*p);\n"
    "    return mix(mix(v.x, v.y, p.x), mix(v.z, v.w, p.x), p.y);\n"
    "}\n"
    "\n"
    "float fBm(vec2 p){ return n2D3G(p)*.66 + n2D3G(p*2.)*.34; }\n"
    "\n"
    "// Refactored to pass cellID out instead of using a global\n"
    "float bMap(vec2 p, out vec2 cellID) {\n"
    "    p *= rot2(-3.14159/5.);\n"
    "    #ifdef OFFSET_ROW\n"
    "    if(mod(floor(p.y), 2.)<.5) p.x += .5;\n"
    "    #endif\n"
    "    vec2 ip = floor(p);\n"
    "    p -= ip + .5;\n"
    "    cellID = ip;\n"
    "    float ang = -3.14159*3./5. + (fBm(ip/8. + time/3.))*6.2831*2.;\n"
    "    vec2 offs = vec2(cos(ang), sin(ang))*.35;\n"
    "    if(p.x<offs.x)  p.x = 1. - (p.x + .5)/abs(offs.x  + .5);\n"
    "    else p.x = (p.x - offs.x)/(.5 - offs.x);\n"
    "    if(p.y<offs.y) p.y = 1. - (p.y + .5)/abs(offs.y + .5);\n"
    "    else p.y = (p.y - offs.y)/(.5 - offs.y);\n"
    "    return 1. - max(p.x, p.y);\n"
    "}\n"
    "\n"
    "vec3 doBumpMap(in vec2 p, in vec3 n, float bumpfactor, inout float edge){\n"
    "    vec2 e = vec2(.025, 0);\n"
    "    vec2 cell_id; // Dummy variable, not used here but needed by bMap\n"
    "    float f = bMap(p, cell_id);\n"
    "    float fx = bMap(p - e.xy, cell_id);\n"
    "    float fy = bMap(p - e.yx, cell_id);\n"
    "    float fx2 = bMap(p + e.xy, cell_id);\n"
    "    float fy2 = bMap(p + e.yx, cell_id);\n"
    "    vec3 grad = (vec3(fx - fx2, fy - fx2, 0))/e.x/2.;\n"
    "    edge = length(vec2(fx, fy) + vec2(fx2, fy2) - f*2.);\n"
    "    edge = smoothstep(0., 1., edge/e.x);\n"
    "    grad -= n*dot(n, grad);\n"
    "    return normalize( n + grad*bumpfactor );\n"
    "}\n"
    "\n"
    "float doHatch(vec2 p, float res){\n"
    "    p *= res/16.;\n"
    "    float hatch = clamp(sin((p.x - p.y)*3.14159*200.)*2. + .5, 0., 1.);\n"
    "    float hRnd = hash21(floor(p*6.) + .73);\n"
    "    if(hRnd>.66) hatch = hRnd;\n"
    "    return hatch;\n"
    "}\n"
    "// --- End of Pyramid Pattern Helper Functions ---\n"
    "\n"
    "// --- Start of Panel Masking Function ---\n"
    "float sdfTopRoundBox2D(vec2 p, vec2 b, float r) {\n"
    "    r = min(r, min(b.x, b.y));\n"
    "    bool roundTopLeft = false, roundTopRight = false, roundBottomLeft = true, roundBottomRight = true;\n"
    "    if (p.x < -b.x + r && p.y > b.y - r && roundTopLeft) { return length(p - vec2(-b.x + r, b.y - r)) - r; }\n"
    "    if (p.x > b.x - r && p.y > b.y - r && roundTopRight) { return length(p - vec2(b.x - r, b.y - r)) - r; }\n"
    "    if (p.x < -b.x + r && p.y < -b.y + r && roundBottomLeft) { return length(p - vec2(-b.x + r, -b.y + r)) - r; }\n"
    "    if (p.x > b.x - r && p.y < -b.y + r && roundBottomRight) { return length(p - vec2(b.x - r, -b.y + r)) - r; }\n"
    "    vec2 q = abs(p) - b;\n"
    "    return max(q.x, q.y);\n"
    "}\n"
    "// --- End of Panel Masking Function ---\n"
    "\n"
    "void main() {\n"
    "    vec2 fragCoord = v_texcoord * iResolution;\n"
    "    float iTime = time;\n"
    "\n"
    "    // --- DEFINE PATTERN SCALE HERE ---\n"
    "    float patternScale = 800.0; // LARGER number = SMALLER pattern.\n"
    "\n"
    "    // --- Core Pattern Logic ---\n"
    "    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / patternScale;\n"
    "   uv *=4.0 ; \n"
    "    vec3 col;\n"
    "    {\n"
    "        // This block is the adapted main logic from the Pyramid shader.\n"
    "        vec3 rd = normalize(vec3(uv, .5));\n"
    "        const float gSc = 10.;\n"
    "        vec2 p = uv*gSc + vec2(0, iTime/2.);\n"
    "        vec2 oP = p;\n"
    "        vec2 svID; // Local variable for cell ID\n"
    "        float m = bMap(p, svID);\n"
    "        vec3 n = vec3(0, 0, -1);\n"
    "        float edge = 0., bumpFactor = .25;\n"
    "        n = doBumpMap(p, n, bumpFactor, edge);\n"
    "        vec3 lp = vec3(-0. + sin(iTime)*.3, .0 + cos(iTime*1.3)*.3, -1) - vec3(uv, 0);\n"
    "        float lDist = max(length(lp), .001);\n"
    "        vec3 ld = lp/lDist;\n"
    "        float diff = max(dot(n, ld), 0.);\n"
    "        diff = pow(diff, 4.);\n"
    "        float spec = pow(max(dot(reflect(-ld, n), -rd), 0.), 16.);\n"
    "        float fre = min(pow(max(1. + dot(n, rd), 0.), 4.), 3.);\n"
    "        col = vec3(.15)*(diff + .251 + spec*vec3(1, .7, .3)*9. + fre*vec3(.1, .3, 1)*12.);\n"
    "        vec2 dummy_id;\n"
    "        float rf = smoothstep(0., .35, bMap(reflect(rd, n).xy*2., dummy_id)*fBm(reflect(rd, n).xy*3.) + .1);\n"
    "        col += col*col*rf*rf*vec3(1, .1, .1)*15.;\n"
    "        float shade = m*.83 + .17;\n"
    "        col *= shade;\n"
    "        col *= 1. - edge*.8;\n"
    "        // Use patternScale to keep hatch size consistent with the main pattern\n"
    "        float hatch = doHatch(oP/gSc, patternScale);\n"
    "        col *= hatch*.5 + .7;\n"
    "    }\n"
    "    // --- End of Core Pattern Logic ---\n"
    "\n"
    "    // Apply gamma correction from original Pyramid shader\n"
    "    vec3 final_pattern_color = sqrt(max(col, 0.));\n"
    "\n"
    "    // --- MASKING logic (remains the same) ---\n"
    "    vec2 pixel_pos = (v_texcoord - 0.5) * iResolution;\n"
    "    vec2 box_half_extents_pixels = iResolution * 0.5;\n"
    "    float corner_radius_pixels = 40.0;\n"
    "    float dist_to_edge = sdfTopRoundBox2D(pixel_pos, box_half_extents_pixels, corner_radius_pixels);\n"
    "    float aa_pixels = 2.0;\n"
    "\n"
    "    float shape_alpha_mask = 1.0 - smoothstep(-aa_pixels * 0.5, aa_pixels * 0.5, dist_to_edge);\n"
    "    shape_alpha_mask = clamp(shape_alpha_mask, 0.0, 1.0);\n"
    "\n"
    "    // Combine the pattern color with the shape mask\n"
    "    frag_color = vec4(final_pattern_color, shape_alpha_mask);\n"
    "}\n"
    "// --- End of shader ---";  
    */
    
    static const char *ssd_fragment_shader_src =
    "#version 300 es\n"
    "precision highp float;\n"
    "\n"
    "in vec2 v_texcoord;\n"
    "out vec4 frag_color;\n"
    "\n"
    "uniform float time;\n"
    "uniform vec2 iResolution;\n"
    "\n"
    "// --- Effect Parameters ---\n"
    "const float cornerRadius = 20.0;\n" // Reduced to fit smaller boxes
    "const float borderWidth = 2.0;\n"   // Reduced for smaller boxes
    "const float aa = 1.5;\n"
    "\n"
    "// --- Helper Functions ---\n"
    "float sdRoundedBox(vec2 p, vec2 b, float r) {\n"
    "    vec2 q = abs(p) - b + r;\n"
    "    return min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r;\n"
    "}\n"
    "\n"
    "vec3 hsv2rgb(vec3 c) {\n"
    "    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n"
    "    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n"
    "    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n"
    "}\n"
    "\n"
    "float hash21(vec2 p) {\n"
    "    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n"
    "}\n"
    "\n"
    "vec2 hash22(vec2 p) {\n"
    "    float n = sin(dot(p, vec2(41.0, 289.0)));\n"
    "    return fract(vec2(262144.0, 32768.0) * n);\n"
    "}\n"
    "\n"
    "// --- Voronoi Pattern Function ---\n"
    "vec3 voronoiEffect(vec2 uv, float time) {\n"
    "    vec2 p = uv * iResolution / 150.0;\n"
    "    vec2 i = floor(p);\n"
    "    vec2 f = fract(p);\n"
    "    float minDist = 1.0;\n"
    "    vec2 minPoint;\n"
    "    float cellId = 0.0;\n"
    "    for (int y = -1; y <= 1; y++) {\n"
    "        for (int x = -1; x <= 1; x++) {\n"
    "            vec2 neighbor = vec2(float(x), float(y));\n"
    "            vec2 point = hash22(i + neighbor);\n"
    "            point = 0.5 + 0.5 * sin(time * 0.5 + 6.2831 * point);\n"
    "            vec2 diff = neighbor + point - f;\n"
    "            float dist = length(diff);\n"
    "            if (dist < minDist) {\n"
    "                minDist = dist;\n"
    "                minPoint = point;\n"
    "                cellId = hash21(i + neighbor);\n"
    "            }\n"
    "        }\n"
    "    }\n"
    "    float hue = fract(cellId + time * 0.1);\n"
    "    float saturation = 0.7 + 0.3 * sin(minDist * 5.0);\n"
    "    float brightness = 0.6 + 0.4 * cos(minDist * 3.0 + time);\n"
    "    vec3 color = hsv2rgb(vec3(hue, saturation, brightness));\n"
    "    float border = smoothstep(0.05, 0.1, minDist);\n"
    "    color *= (1.0 - border * 0.5);\n"
    "    return color;\n"
    "}\n"
    "\n"
    "void main() {\n"
    "    vec2 p = (v_texcoord - 0.5) * iResolution;\n"
    "    vec2 grid_uv = v_texcoord * 2.0;\n"
    "    vec2 grid_id = floor(grid_uv);\n"
    "    vec2 grid_coord = fract(grid_uv);\n"
    "    vec2 grid_center = (grid_id - 0.5) * 0.5;\n"
    "    vec2 box_pos = p - grid_center * iResolution * 0.5;\n"
    "    vec2 box_size = iResolution * 0.2;\n" // Smaller boxes (0.4 * 0.5 for grid)
    "    float d = sdRoundedBox(box_pos, box_size, cornerRadius);\n"
    "\n"
    "    vec3 fill_color = vec3(0.0);\n"
    "    float final_alpha = 0.0;\n"
    "    if (grid_id.x < 2.0 && grid_id.y < 2.0) {\n"
    "        fill_color = voronoiEffect(grid_coord, time);\n"
    "        vec3 border_color = hsv2rgb(vec3(fract(time * 0.15), 0.9, 1.0));\n"
    "        float border_mix = smoothstep(-borderWidth, -borderWidth + aa, d);\n"
    "        vec3 final_rgb = mix(border_color, fill_color, border_mix);\n"
    "        float border_alpha = 0.95;\n"
    "        float fill_alpha = 0.0;\n"
    "        final_alpha = mix(border_alpha, fill_alpha, border_mix);\n"
    "        final_alpha *= (1.0 - smoothstep(-aa, aa, d));\n"
    "        frag_color = vec4(final_rgb, final_alpha).bgra;\n"
    "    } else {\n"
    "        frag_color = vec4(0.0, 0.0, 0.0, 0.0).bgra;\n"
    "    }\n"
    "}\n";

/*
// Add these near your other shader source strings
static const char *fullscreen_vertex_shader_src =
       "#version 300 es\n"
       "precision mediump float;\n"
       "layout(location = 0) in vec2 a_position_01;\n" // Vertices of the quad (0,0 to 1,1)
       "layout(location = 1) in vec2 a_texcoord;\n"    // Texture coords for the quad (0,0 to 1,1)
       "uniform mat3 mvp;\n"
       "out vec2 v_texcoord_to_fs;\n"
       "void main() {\n"
       "    gl_Position = vec4((mvp * vec3(a_position_01, 1.0)).xy, 0.0, 1.0);\n"
       // Pass texture coordinates directly. The FBO texture (scene content)
       // will be mapped entirely onto the scaled quad.
       "    v_texcoord_to_fs = a_texcoord;\n"
       "}\n";

static const char *expo_fragment_shader_src =
       "#version 300 es\n"
       "precision mediump float;\n"
       "in vec2 v_texcoord_to_fs;\n"
       "out vec4 frag_color;\n"
       "uniform sampler2D u_scene_texture;\n"
       "void main() {\n"
       "    vec4 original_color = texture(u_scene_texture, v_texcoord_to_fs);\n"
       "    vec3 inverted_rgb = vec3(1.0) - original_color.rgb;\n" // Invert R, G, B
       "    frag_color = vec4(inverted_rgb, original_color.a);\n"  // Keep original alpha
       "}\n";
*//*
static const char *fullscreen_vertex_shader_src =
       "#version 300 es\n"
       "precision mediump float;\n"
       "layout(location = 0) in vec2 a_position_01;\n" // Vertices of the quad (0,0 to 1,1)
       "layout(location = 1) in vec2 a_texcoord;\n"    // Texture coords for the quad (0,0 to 1,1)
       "uniform mat3 mvp;\n"
       "out vec2 v_texcoord_to_fs;\n"
       "void main() {\n"
       "    float zoom = 0.5; // 2x smaller\n"
       "    \n"
       "    // Scale the quad geometry and position it based on which instance/quadrant\n"
       "    vec2 scaled_pos = a_position_01 * zoom;\n"
       "    \n"
       "    // Offset to different quadrants (you'd need to pass quadrant info)\n"
       "    // For now, this will scale everything to center\n"
       "    vec2 center_offset = vec2(0.5 - zoom * 0.5);\n"
       "    vec2 final_pos = scaled_pos + center_offset;\n"
       "    \n"
       "    gl_Position = vec4((mvp * vec3(final_pos, 1.0)).xy, 0.0, 1.0);\n"
       // Pass texture coordinates directly. The FBO texture (scene content)\n"
       // will be mapped entirely onto the scaled quad.\n"
       "    v_texcoord_to_fs = a_texcoord;\n"
       "}\n";

static const char *expo_fragment_shader_src =
       "#version 300 es\n"
       "precision mediump float;\n"
       "in vec2 v_texcoord_to_fs;\n"
       "out vec4 frag_color;\n"
       "uniform sampler2D u_scene_texture;\n"
       "void main() {\n"
       "    vec4 original_color = texture(u_scene_texture, v_texcoord_to_fs);\n"
       "    vec3 inverted_rgb = vec3(1.0) - original_color.rgb;\n" // Invert R, G, B
       "    frag_color = vec4(inverted_rgb, original_color.a);\n"  // Keep original alpha
       "}\n";*/




/*interesting effcet
static const char *fullscreen_vertex_shader_src =
       "#version 300 es\n"
       "precision mediump float;\n"
       "layout(location = 0) in vec2 a_position_01;\n"
       "layout(location = 1) in vec2 a_texcoord;\n"
       "\n"
       // MVP is not directly used by this shader logic for positioning quadrants
       // uniform mat3 mvp; \n"
       "uniform float u_zoom;        // Main Q0 zoom: 1.0 (normal) to 2.0 (Q0 fullscreen)\n"
       "uniform int u_quadrant;      // <<< ORIGINAL AND CONSISTENT NAME NOW\n"
       "\n"
       "out vec2 v_texcoord_to_fs;\n"
       "\n"
       "const float ANIM_PARAM_MAX = 1.0; \n"
       "\n"
       "void main() {\n"
       "    vec2 final_ndc_pos;\n"
       "    float t_anim = (u_zoom - 1.0) / ANIM_PARAM_MAX; \n"
       "    t_anim = clamp(t_anim, 0.0, 1.0);\n"
       "\n"
       "    if (u_quadrant == 0) { // MAIN ZOOMING QUADRANT (Top-Left)\n"
       "        float main_quad_ndc_span = 1.0 + t_anim;\n"
       "        final_ndc_pos.x = -1.0 + (a_position_01.x * main_quad_ndc_span);\n"
       "        final_ndc_pos.y =  1.0 - (a_position_01.y * main_quad_ndc_span);\n"
       "\n"
       "    } else { // --- Other (non-main) quadrants --- \n"
       "        float other_quad_scale = 1.0 - t_anim;\n"
       "        vec2 quad_min_ndc, quad_max_ndc, anchor_ndc;\n"
       "\n"
       "        if (u_quadrant == 1) { // Top-Right Quadrant\n"
       "            quad_min_ndc = vec2(0.0, 0.0);\n"
       "            quad_max_ndc = vec2(1.0, 1.0);\n"
       "            anchor_ndc   = vec2(1.0, 1.0);\n"
       "        } else if (u_quadrant == 2) { // Bottom-Left Quadrant\n"
       "            quad_min_ndc = vec2(-1.0, -1.0);\n"
       "            quad_max_ndc = vec2(0.0, 0.0);\n"
       "            anchor_ndc   = vec2(-1.0, -1.0);\n"
       "        } else { // u_quadrant == 3, Bottom-Right Quadrant\n"
       "            quad_min_ndc = vec2(0.0, -1.0);\n"
       "            quad_max_ndc = vec2(1.0, 0.0);\n"
       "            anchor_ndc   = vec2(1.0, -1.0);\n"
       "        }\n"
       "\n"
       "        vec2 vertex_in_unscaled_quad_ndc;\n"
       "        vertex_in_unscaled_quad_ndc.x = mix(quad_min_ndc.x, quad_max_ndc.x, a_position_01.x);\n"
       "        vertex_in_unscaled_quad_ndc.y = mix(quad_min_ndc.y, quad_max_ndc.y, 1.0 - a_position_01.y);\n"
       "\n"
       "        final_ndc_pos = (vertex_in_unscaled_quad_ndc - anchor_ndc) * other_quad_scale + anchor_ndc;\n"
       "    }\n"
       "\n"
       "    gl_Position = vec4(final_ndc_pos, 0.0, 1.0);\n"
       "    v_texcoord_to_fs = vec2(a_texcoord.x, 1.0 - a_texcoord.y);\n"
       "}\n";*/

// Vertex Shader
static const char *fullscreen_vertex_shader_src =
       "#version 300 es\n"
       "precision mediump float;\n"
       "layout(location = 0) in vec2 a_position_01;\n"
       "layout(location = 1) in vec2 a_texcoord;\n"
       "\n"
       "uniform float u_zoom;       // 1.0 to 2.0\n"
       "uniform highp int u_quadrant;    // Which quadrant to expand (0-3)\n"
       "\n"
       "out vec2 v_texcoord_to_fs;\n"
       "\n"
       "void main() {\n"
       "    gl_Position = vec4(a_position_01 * 2.0 - 1.0, 0.0, 1.0);\n"
       "    v_texcoord_to_fs = a_texcoord;\n"
       "}\n";

// Fragment Shader
/*
static const char *expo_fragment_shader_src =
"#version 300 es\n"
"precision mediump float;\n"
"precision mediump int;\n"
"\n"
"uniform sampler2D u_scene_texture0;  // Texture for top-left quadrant\n"
"uniform sampler2D u_scene_texture1;  // Texture for top-right quadrant\n"
"uniform sampler2D u_scene_texture2;  // Texture for bottom-left quadrant\n"
"uniform sampler2D u_scene_texture3;  // Texture for bottom-right quadrant\n"
"uniform float u_zoom;               // 1.0 to 2.0\n"
"uniform highp int u_quadrant;       // Which quadrant to expand (0-3)\n"
"\n"
"in vec2 v_texcoord_to_fs;\n"
"out vec4 FragColor;\n"
"\n"
"void main() {\n"
"    float t = clamp(u_zoom - 1.0, 0.0, 1.0);\n"
"    vec2 uv = v_texcoord_to_fs;\n"
"    \n"
"    // Define the center point of each quadrant in the 2x2 grid\n"
"    vec2 quad_centers[4];\n"
"    quad_centers[0] = vec2(0.0, 1.0);  // Top-left\n"
"    quad_centers[1] = vec2(1.0, 1.0);  // Top-right\n"
"    quad_centers[2] = vec2(0.00, 0.00);  // Bottom-left\n"
"    quad_centers[3] = vec2(1.00, 0.00);  // Bottom-right\n"
"    \n"
"    // Get the center of the selected quadrant\n"
"    vec2 zoom_center = quad_centers[u_quadrant];\n"
"    \n"
"    // Transform UV: zoom in from the selected quadrant's center\n"
"    vec2 offset_from_center = uv - zoom_center;\n"
"    vec2 scaled_offset = offset_from_center / (1.0 + t);\n"
"    vec2 transformed_uv = zoom_center + scaled_offset;\n"
"    \n"
"    // Map the transformed UV to the original texture coordinates\n"
"    vec2 texture_uv;\n"
"    int target_quad;\n"
"    if (transformed_uv.x < 0.5 && transformed_uv.y > 0.5) target_quad = 0;\n"
"    else if (transformed_uv.x > 0.5 && transformed_uv.y > 0.5) target_quad = 1;\n"
"    else if (transformed_uv.x < 0.5 && transformed_uv.y < 0.5) target_quad = 2;\n"
"    else target_quad = 3;\n"
"    \n"
"    // Map to texture coordinates based on which quadrant\n"
"    if (target_quad == 0) {\n"
"        // Top-left quadrant\n"
"        texture_uv = vec2(transformed_uv.x * 2.0, (transformed_uv.y - 0.5) * 2.0);\n"
"        FragColor = texture(u_scene_texture0, texture_uv);\n"
"    } else if (target_quad == 1) {\n"
"        // Top-right quadrant\n"
"        texture_uv = vec2((transformed_uv.x - 0.5) * 2.0, (transformed_uv.y - 0.5) * 2.0);\n"
"        FragColor = texture(u_scene_texture1, texture_uv);\n"
"    } else if (target_quad == 2) {\n"
"        // Bottom-left quadrant\n"
"        texture_uv = vec2(transformed_uv.x * 2.0, transformed_uv.y * 2.0);\n"
"        FragColor = texture(u_scene_texture2, texture_uv);\n"
"    } else {\n"
"        // Bottom-right quadrant\n"
"        texture_uv = vec2((transformed_uv.x - 0.5) * 2.0, transformed_uv.y * 2.0);\n"

"        FragColor = texture(u_scene_texture3, texture_uv);\n"
"    }\n"
"}\n";
*/

static const char *expo_fragment_shader_src =
"#version 300 es\n"
"precision mediump float;\n"
"precision mediump int;\n"
"\n"
"uniform sampler2D u_scene_texture0;   // Desktop 0 (row 0, col 0)\n"
"uniform sampler2D u_scene_texture1;   // Desktop 1 (row 0, col 1)\n"
"uniform sampler2D u_scene_texture2;   // Desktop 2 (row 0, col 2)\n"
"uniform sampler2D u_scene_texture3;   // Desktop 3 (row 0, col 3)\n"
"uniform sampler2D u_scene_texture4;   // Desktop 4 (row 1, col 0)\n"
"uniform sampler2D u_scene_texture5;   // Desktop 5 (row 1, col 1)\n"
"uniform sampler2D u_scene_texture6;   // Desktop 6 (row 1, col 2)\n"
"uniform sampler2D u_scene_texture7;   // Desktop 7 (row 1, col 3)\n"
"uniform sampler2D u_scene_texture8;   // Desktop 8 (row 2, col 0)\n"
"uniform sampler2D u_scene_texture9;   // Desktop 9 (row 2, col 1)\n"
"uniform sampler2D u_scene_texture10;  // Desktop 10 (row 2, col 2)\n"
"uniform sampler2D u_scene_texture11;  // Desktop 11 (row 2, col 3)\n"
"uniform sampler2D u_scene_texture12;  // Desktop 12 (row 3, col 0)\n"
"uniform sampler2D u_scene_texture13;  // Desktop 13 (row 3, col 1)\n"
"uniform sampler2D u_scene_texture14;  // Desktop 14 (row 3, col 2)\n"
"uniform sampler2D u_scene_texture15;  // Desktop 15 (row 3, col 3)\n"
"uniform float u_zoom;                 // 1.0 to 2.0\n"
"uniform float u_move;\n"
"uniform highp int u_quadrant;         // Which desktop to expand (0-15)\n"
"uniform int DesktopGrid;\n"
"uniform int switch_mode;\n"
"uniform int u_switchXY;\n"
"\n"
"in vec2 v_texcoord_to_fs;\n"
"out vec4 FragColor;\n"
"\n"
"vec4 sampleDesktop(int desktop_id, vec2 uv) {\n"
"    if (desktop_id == 0) return texture(u_scene_texture0, uv);\n"
"    else if (desktop_id == 1) return texture(u_scene_texture1, uv);\n"
"    else if (desktop_id == 2) return texture(u_scene_texture2, uv);\n"
"    else if (desktop_id == 3) return texture(u_scene_texture3, uv);\n"
"    else if (desktop_id == 4) return texture(u_scene_texture4, uv);\n"
"    else if (desktop_id == 5) return texture(u_scene_texture5, uv);\n"
"    else if (desktop_id == 6) return texture(u_scene_texture6, uv);\n"
"    else if (desktop_id == 7) return texture(u_scene_texture7, uv);\n"
"    else if (desktop_id == 8) return texture(u_scene_texture8, uv);\n"
"    else if (desktop_id == 9) return texture(u_scene_texture9, uv);\n"
"    else if (desktop_id == 10) return texture(u_scene_texture10, uv);\n"
"    else if (desktop_id == 11) return texture(u_scene_texture11, uv);\n"
"    else if (desktop_id == 12) return texture(u_scene_texture12, uv);\n"
"    else if (desktop_id == 13) return texture(u_scene_texture13, uv);\n"
"    else if (desktop_id == 14) return texture(u_scene_texture14, uv);\n"
"    else return texture(u_scene_texture15, uv);\n"
"}\n"
"\n"
"void main() {\n"
"    if (switch_mode == 0) {\n"
"        // --- ZOOM MODE (4x4 grid) ---\n"
"        float t = clamp(u_zoom - 1.0, 0.0, 1.0) * (float(DesktopGrid) - 1.0);\n"
"        vec2 uv = v_texcoord_to_fs;\n"
"        \n"
"        // Calculate logical row and column of the selected desktop (e.g., top-left is row 0, col 0)\n"
"        int selected_row = u_quadrant / DesktopGrid;\n"
"        int selected_col = u_quadrant % DesktopGrid;\n"
"        \n"
"        // Calculate the zoom center in screen coordinates\n"
"        // We invert the selected_row because screen Y-coordinates are 0 at the bottom.\n"
"        vec2 zoom_center = vec2(\n"
"            float(selected_col) / (float(DesktopGrid) - 1.0), \n"
"            float((DesktopGrid - 1) - selected_row) / float(DesktopGrid - 1)\n"
"        );\n"
"        \n"
"        // Transform UV: zoom in from the selected desktop's center\n"
"        vec2 offset_from_center = uv - zoom_center;\n"
"        vec2 scaled_offset = offset_from_center / (1.0 + t);\n"
"        vec2 transformed_uv = zoom_center + scaled_offset;\n"
"        \n"
"        // Determine which desktop we're sampling from in the 4x4 grid\n"
"        // Invert the row lookup to match the visual layout\n"
"        int target_row = (DesktopGrid - 1) - int(floor(transformed_uv.y * float(DesktopGrid)));\n"
"        int target_col = int(floor(transformed_uv.x * float(DesktopGrid)));\n"
"        \n"
"        // Clamp to valid range\n"
"        target_row = clamp(target_row, 0, 3);\n"
"        target_col = clamp(target_col, 0, 3);\n"
"        \n"
"        int target_desktop = target_row * DesktopGrid + target_col;\n"
"        \n"
"        // Calculate texture coordinates within the desktop\n"
"        vec2 texture_uv = vec2(\n"
"            fract(transformed_uv.x * float(DesktopGrid)),\n"
"            fract(transformed_uv.y * float(DesktopGrid))\n"
"        );\n"
"        \n"
"        vec4 color = sampleDesktop(target_desktop, texture_uv);\n"
"        FragColor = color;\n"
"        \n"
"    } else if (switch_mode == 1) {\n"
"        // --- SLIDE MODE ---\n"
"        float slide_progress = clamp(u_move - 1.0, 0.0, 1.0);\n"
"        vec2 uv = v_texcoord_to_fs;\n"
"        float slide_offset = slide_progress;\n"
"        \n"
"        int current_desktop = u_quadrant;\n"
"        int next_desktop;\n"
"        \n"
"        vec2 current_uv, next_uv;\n"
"\n"
"        if (u_switchXY == 0) {\n"
"            // === HORIZONTAL SLIDE LOGIC (4x4 grid) ===\n"
"            int current_row = current_desktop / 4;\n"
"            int current_col = current_desktop % 4;\n"
"            \n"
"            // Move to next column in same row (wrap around)\n"
"            int next_col = (current_col + 1) % 4;\n"
"            next_desktop = current_row * 4 + next_col;\n"
"\n"
"            // Current desktop slides LEFT, next desktop is revealed from RIGHT\n"
"            current_uv = vec2(uv.x + slide_offset, uv.y);\n"
"            next_uv    = vec2(uv.x + slide_offset - 1.0, uv.y);\n"
"\n"
"        } else {\n"
"            // === VERTICAL SLIDE LOGIC (4x4 grid) ===\n"
"            int current_row = current_desktop / 4;\n"
"            int current_col = current_desktop % 4;\n"
"            \n"
"            // Move to next row in same column (wrap around)\n"
"            int next_row = (current_row + 1) % 4;\n"
"            next_desktop = next_row * 4 + current_col;\n"
"\n"
"            // Current desktop slides UP, next desktop is revealed from BOTTOM\n"
"            current_uv = vec2(uv.x, uv.y + slide_offset);\n"
"            next_uv    = vec2(uv.x, uv.y + slide_offset - 1.0);\n"
"        }\n"
"        \n"
"        vec4 current_color = sampleDesktop(current_desktop, current_uv);\n"
"        vec4 next_color = sampleDesktop(next_desktop, next_uv);\n"
"        \n"
"        // Choose which color to use based on whether the current UV is within bounds\n"
"        vec4 color;\n"
"        if (current_uv.x >= 0.0 && current_uv.x <= 1.0 && current_uv.y >= 0.0 && current_uv.y <= 1.0) {\n"
"             color = current_color;\n"
"        } else {\n"
"             color = next_color;\n"
"        }\n"
"        \n"
"        FragColor = color;\n"
"    }\n"
"}\n";
static const char *cube_vertex_shader_src =
       "#version 300 es\n"
       "precision mediump float;\n"
       "layout(location = 0) in vec3 a_position;    // 3D cube vertices\n"
       "layout(location = 1) in vec2 a_texcoord;\n"
       "layout(location = 2) in float a_face_id;    // Face ID (0-5)\n"
       "\n"
       "uniform float u_zoom;           // Zoom factor (higher is further away)\n"
       "uniform float u_rotation_y;     // The final Y rotation angle from C code\n"
       "uniform float u_time;           // Time uniform for animation (add this to your C code)\n"
       "uniform float u_vertical_offset; // Vertical movement offset\n"
       "uniform float GLOBAL_u_vertical_offset; // Vertical movement offset\n"
       "\n"
       "out vec2 v_texcoord_to_fs;\n"
       "out float v_face_id;\n"
       "\n"
       "mat4 rotationX(float angle) {\n"
       "    float c = cos(angle); float s = sin(angle);\n"
       "    return mat4(1.0, 0.0, 0.0, 0.0, 0.0, c, -s, 0.0, 0.0, s, c, 0.0, 0.0, 0.0, 0.0, 1.0);\n"
       "}\n"
       "\n"
       "mat4 rotationY(float angle) {\n"
       "    float c = cos(angle); float s = sin(angle);\n"
       "    return mat4(c, 0.0, s, 0.0, 0.0, 1.0, 0.0, 0.0, -s, 0.0, c, 0.0, 0.0, 0.0, 0.0, 1.0);\n"
       "}\n"
       "\n"
       "mat4 perspective(float fov, float aspect, float near, float far) {\n"
       "    float f = 1.0 / tan(fov * 0.5);\n"
       "    return mat4(f/aspect, 0.0, 0.0, 0.0, 0.0, f, 0.0, 0.0, 0.0, 0.0, (far+near)/(near-far), -1.0, 0.0, 0.0, (2.0*far*near)/(near-far), 0.0);\n"
       "}\n"
       "\n"
       "void main() {\n"
       "    float zoom_distance = 1.8 - (u_zoom - 1.85) * 1.0;\n"
       "    float slight_x_rotation = 0.0; // ~11 degrees for a better view\n"
       "\n"
       "    mat4 rotX = rotationX(slight_x_rotation);\n"
       "    mat4 rotY = rotationY(u_rotation_y); // Use the angle passed directly from C\n"
       "\n"
       "    vec4 pos = vec4(a_position, 1.0);\n"
       "    \n"
       "    // Scale the geometry to make side faces rectangular while keeping top/bottom square\n"
       "    // Assuming your textures have a 16:9 or similar aspect ratio\n"
       "    float aspect_ratio = 1.0; // Adjust this to match your actual texture aspect ratio\n"
       "    \n"
       "    // Only scale the Y dimension for side faces (faces 0-3)\n"
       "    // Top and bottom faces (4-5) remain square but will be distorted\n"
       "    int face = int(round(a_face_id));\n"
       "    if (face >= 3 && face <= 0) {\n"
       "        // Side faces: scale Y to match texture aspect ratio\n"
       "        pos.y *= aspect_ratio;\n"
       "    }\n"
       "    // Top and bottom faces (4-5) keep original scaling\n"
       "    \n"
       "    pos = rotY * rotX * pos;\n"
       "    pos.z -= zoom_distance;\n"
       "   pos.y -= u_vertical_offset;\n"
       "   pos.y -= GLOBAL_u_vertical_offset;\n"
       "\n"
       "    mat4 proj = perspective(45.0 * 3.14159 / 180.0, 1.0, 0.1, 10.0);\n"
       "    gl_Position = proj * pos;\n"
       "\n"
       "    v_texcoord_to_fs = a_texcoord;\n"
       "    v_face_id = a_face_id;\n"
       "}\n";

/*
// Your cube fragment shader with multicolored background
static const char *cube_fragment_shader_src =
"#version 300 es\n"
"precision mediump float;\n"
"precision highp int;\n" // Use highp for the int uniform
"\n"
"uniform sampler2D u_scene_texture0;\n"
"uniform sampler2D u_scene_texture1;\n"
"uniform sampler2D u_scene_texture2;\n"
"uniform sampler2D u_scene_texture3;\n"
"uniform float u_zoom;               // For brightness/intensity\n"
"uniform highp int u_quadrant;       // Which quadrant to expand (0-3)\n"
"\n"
"in vec2 v_texcoord_to_fs;\n"
"in float v_face_id; // The ID of the cube face being rendered (0-5)\n"
"out vec4 FragColor;\n"
"\n"
"// Function to calculate rounded corner mask\n"
"float roundedCornerMask(vec2 uv, float radius) {\n"
"    // Convert UV to range [-0.5, 0.5] to center the coordinates\n"
"    vec2 centered_uv = uv - 0.5;\n"
"    \n"
"    // Calculate distance from each corner\n"
"    vec2 corner_dist = abs(centered_uv) - (0.5 - radius);\n"
"    \n"
"    // If we're inside the rounded area, return 1.0 (fully opaque)\n"
"    if (corner_dist.x <= 0.0 && corner_dist.y <= 0.0) {\n"
"        return 1.0;\n"
"    }\n"
"    \n"
"    // If we're in a corner region, calculate circular distance\n"
"    if (corner_dist.x > 0.0 && corner_dist.y > 0.0) {\n"
"        float dist_to_corner = length(corner_dist);\n"
"        return smoothstep(radius + 0.01, radius - 0.01, dist_to_corner);\n"
"    }\n"
"    \n"
"    // If we're in an edge region (not corner), return 1.0\n"
"    return 1.0;\n"
"}\n"
"\n"
"// Function to calculate edge anti-aliasing mask\n"
"float edgeAntiAliasMask(vec2 uv) {\n"
"    // Distance to each edge (0.0 at edge, 1.0 at center)\n"
"    float left_dist = uv.x;\n"
"    float right_dist = 1.0 - uv.x;\n"
"    float top_dist = uv.y;\n"
"    float bottom_dist = 1.0 - uv.y;\n"
"    \n"
"    // Find the minimum distance to any edge\n"
"    float min_edge_dist = min(min(left_dist, right_dist), min(top_dist, bottom_dist));\n"
"    \n"
"    // Apply anti-aliasing at the edges\n"
"    float aa_width = 0.01;\n"
"    return smoothstep(0.0, aa_width, min_edge_dist);\n"
"}\n"
"\n"
"void main() {\n"
"    // The texture coordinates for this fragment on the current face (always 0.0-1.0).\n"
"    vec2 uv = v_texcoord_to_fs;\n"
"    \n"
"    // Convert the incoming float face ID to an integer.\n"
"    int face = int(round(v_face_id)); // Use round() for safety\n"
"    int desktop_id = face % 4; // Which desktop this face represents (0-3)\n"
"    \n"
"    // Apply zoom effect when this face matches the selected quadrant\n"
"    vec2 sampling_uv = uv;\n"
"    if (desktop_id == u_quadrant) {\n"
"        // Show full texture but scaled up - no cropping\n"
"        // This makes the texture appear larger on the face\n"
"        sampling_uv = uv; // Use original UV coordinates to show full texture\n"
"    }\n"
"    \n"
"    vec4 color;\n"
"    \n"
"    // *** THE CORRECT LOGIC ***\n"
"    // Use the face ID to select which single texture to sample from.\n"
"    // We use the modulo operator (%) so that the 4 textures repeat\n"
"    // across the 6 faces of the cube.\n"
"    if (face % 4 == 0) {\n"
"        // Faces 0 and 4 will get Desktop 0\n"
"        color = texture(u_scene_texture0, sampling_uv);\n"
"    } else if (face % 4 == 1) {\n"
"        // Faces 1 and 5 will get Desktop 1\n"
"        color = texture(u_scene_texture2, sampling_uv);\n"
"    } else if (face % 4 == 2) {\n"
"        // Face 2 will get Desktop 2\n"
"        color = texture(u_scene_texture1, sampling_uv);\n"
"    } else { // face % 4 == 3\n"
"        // Face 3 will get Desktop 3\n"
"        color = texture(u_scene_texture3, sampling_uv);\n"
"    }\n"
"    \n"
"    // Step 1: Calculate rounded corner mask\n"
"    float corner_radius = 0.08; // Adjust this value to change corner roundness (0.0 = sharp, 0.5 = circle)\n"
"    float corner_mask = roundedCornerMask(uv, corner_radius);\n"
"    \n"
"    // Step 2: Calculate edge anti-aliasing mask\n"
"    float edge_mask = edgeAntiAliasMask(uv);\n"
"    \n"
"    // Combine both masks: corners handle the rounded parts, edges handle the straight parts\n"
"    float final_mask = min(corner_mask, edge_mask);\n"
"    \n"
"    // Apply combined mask by modifying alpha\n"
"    color.a *= final_mask;\n"
"    \n"
"    // Intensity based on zoom (closer zoom = brighter)\n"
"    float intensity = 1.0; //0.7 + (2.0 - u_zoom) * 0.3;\n"
"    color.rgb *= intensity;\n"
"    \n"
"    FragColor = color;\n"
"}\n";*/
// Your cube fragment shader with multicolored background

// Your cube fragment shader with multicolored background// Your cube fragment shader with multicolored background
static const char *cube_fragment_shader_src =
"#version 300 es\n"
"precision mediump float;\n"
"precision highp int;\n" // Use highp for the int uniform
"\n"
"uniform sampler2D u_scene_texture0;\n"
"uniform sampler2D u_scene_texture1;\n"
"uniform sampler2D u_scene_texture2;\n"
"uniform sampler2D u_scene_texture3;\n"
"uniform float u_zoom;               // For brightness/intensity\n"
"uniform highp int u_quadrant;       // Which quadrant to expand (0-3)\n"
"uniform float u_rotation_y;         // Renamed from u_time for clarity in this context\n"
"uniform vec2 iResolution;           // For the cap shader effect\n"
"\n"
"in vec2 v_texcoord_to_fs;\n"
"in float v_face_id; // The ID of the cube face being rendered (0-5)\n"
"out vec4 FragColor;\n"
"\n"
"// Function to calculate rounded corner mask\n"
"float roundedCornerMask(vec2 uv, float radius) {\n"
"    vec2 centered_uv = uv - 0.5;\n"
"    vec2 corner_dist = abs(centered_uv) - (0.5 - radius);\n"
"    if (corner_dist.x <= 0.0 && corner_dist.y <= 0.0) {\n"
"        return 1.0;\n"
"    }\n"
"    if (corner_dist.x > 0.0 && corner_dist.y > 0.0) {\n"
"        float dist_to_corner = length(corner_dist);\n"
"        return smoothstep(radius + 0.01, radius - 0.01, dist_to_corner);\n"
"    }\n"
"    return 1.0;\n"
"}\n"
"\n"
"// Function to calculate edge anti-aliasing mask\n"
"float edgeAntiAliasMask(vec2 uv) {\n"
"    float min_edge_dist = min(min(uv.x, 1.0 - uv.x), min(uv.y, 1.0 - uv.y));\n"
"    float aa_width = 0.01;\n"
"    return smoothstep(0.0, aa_width, min_edge_dist);\n"
"}\n"
"\n"
"// Function to create a fake bump mapping / bevel effect on the edges.\n"
"float edgeBumpEffect(vec2 uv) {\n"
"    float bevel_width = 0.01;\n"
"    float highlight = 1.3;\n"
"    float shadow = 0.7;\n"
"    float min_dist = min(min(uv.x, 1.0 - uv.x), min(uv.y, 1.0 - uv.y));\n"
"    if (min_dist >= bevel_width) {\n"
"        return 1.0;\n"
"    }\n"
"    float gradient = smoothstep(bevel_width, 0.0, min_dist);\n"
"    float x_effect = mix(highlight, shadow, uv.x);\n"
"    float y_effect = mix(highlight, shadow, uv.y);\n"
"    float light_effect = (x_effect + y_effect) * 0.5;\n"
"    return mix(1.0, light_effect, gradient);\n"
"}\n"
"\n"
"void main() {\n"
"    int face = int(round(v_face_id));\n"
"\n"
"    // --- CUBE CAP LOGIC (Black with Centered Grey Ripple) ---\n"
"    if (face >= 4) { // Faces 4 (bottom) and 5 (top) are the caps\n"
"        vec2 uv = v_texcoord_to_fs - 0.5;\n"
"        float frequency = 80.0;\n"
"        float speed = 1.8;\n"
"        float amplitude = 0.1;\n"
"        float dist = length(uv);\n"
"        \n"
"        // Ripple normal calculation\n"
"        float height = sin(dist * frequency - u_rotation_y * speed) * amplitude;\n"
"        float delta = 0.001;\n"
"        float hX1 = sin(length(uv + vec2(delta, 0.0)) * frequency - u_rotation_y * speed) * amplitude;\n"
"        float hX2 = sin(length(uv - vec2(delta, 0.0)) * frequency - u_rotation_y * speed) * amplitude;\n"
"        float dx = (hX1 - hX2) / (2.0 * delta);\n"
"        float hY1 = sin(length(uv + vec2(0.0, delta)) * frequency - u_rotation_y * speed) * amplitude;\n"
"        float hY2 = sin(length(uv - vec2(0.0, delta)) * frequency - u_rotation_y * speed) * amplitude;\n"
"        float dy = (hY1 - hY2) / (2.0 * delta);\n"
"        vec3 normal = normalize(vec3(-dx, -dy, 1.0));\n"
"        vec3 lightDir = normalize(vec3(0.3, sin(u_rotation_y * 0.2), 0.5));\n"
"        \n"
"        // Ripple color calculation\n"
"        float ripple_brightness = clamp(dot(normal, lightDir) + 0.5, 0.0, 1.0);\n"
"        vec3 final_color = vec3(0.0);\n"
"        float ripple_intensity = 0.35;\n"
"        vec3 grey_ripple_color = vec3(ripple_brightness * ripple_intensity);\n"
"        final_color += grey_ripple_color;\n"
"        \n"
"        // --- FIX: Apply rounded corner mask to the cap color ---\n"
"        float corner_radius = 0.08; // Use the same radius as the sides\n"
"        float corner_mask = roundedCornerMask(v_texcoord_to_fs, corner_radius);\n"
"        float edge_mask = edgeAntiAliasMask(v_texcoord_to_fs);\n"
"        float final_mask = min(corner_mask, edge_mask);\n"
"        \n"
"        FragColor = vec4(final_color, final_mask);\n"
"        return; // Exit early\n"
"    }\n"
"\n"
"    // --- SIDE FACE LOGIC (EXISTING) ---\n"
"    vec2 uv = v_texcoord_to_fs;\n"
"    int desktop_id = face % 4;\n"
"    vec2 sampling_uv = uv;\n"
"    vec4 color;\n"
"\n"
"    if (face % 4 == 0) {\n"
"        color = texture(u_scene_texture0, sampling_uv);\n"
"    } else if (face % 4 == 1) {\n"
"        color = texture(u_scene_texture2, sampling_uv);\n"
"    } else if (face % 4 == 2) {\n"
"        color = texture(u_scene_texture1, sampling_uv);\n"
"    } else { // face % 4 == 3\n"
"        color = texture(u_scene_texture3, sampling_uv);\n"
"    }\n"
"\n"
"    float bump_factor = edgeBumpEffect(uv);\n"
"    float corner_radius = 0.08;\n"
"    float corner_mask = roundedCornerMask(uv, corner_radius);\n"
"    float edge_mask = edgeAntiAliasMask(uv);\n"
"    color.rgb *= bump_factor;\n"
"    float final_mask = min(corner_mask, edge_mask);\n"
"    color.a *= final_mask;\n"
"    float intensity = 1.0;\n"
"    color.rgb *= intensity;\n"
"    FragColor = color;\n"
"}\n";
//https://www.shadertoy.com/view/WcKGWd
static const char *desktop_0_fs_src =
    "/* Creative Commons Licence Attribution-NonCommercial-ShareAlike \n"
    "phreax/jiagual 2025 \n"
    "Variation of https://www.shadertoy.com/view/tfG3zt\n"
    "             https://www.shadertoy.com/view/3XjXzK\n"
    "Inspired by Xor's recent volumetric shaders\n"
    "https://www.shadertoy.com/view/tXlXDX\n"
    "*/\n"
    "#version 300 es\n"
    "precision mediump float;\n"
    "\n"
    "in vec2 v_texcoord;\n"
    "out vec4 frag_color;\n"
    "\n"
    "uniform float time;\n"
    "uniform vec4 u_color;\n"
    "\n"
    "#define PALETTE 6\n"
    "\n"
    "mat2 rot(float x) {return mat2(cos(x), -sin(x), sin(x), cos(x));}\n"
    "vec3 pal(float x) {return .5+.5*cos(6.28*x-vec3(5,4,1));}\n"
    "\n"
    "vec3 getPal(int palette, float x) {\n"
    "    return pal(x);\n"
    "}\n"
    "\n"
    "#define SIN(x) sin(x)\n"
    "\n"
    "void main() {\n"
    "    vec2 fragCoord = gl_FragCoord.xy;\n"
    "    vec2 iResolution = vec2(1024.0, 768.0);\n"
    "    float iTime = time * 0.5;\n"
    "    \n"
    "    vec2 uv = (fragCoord - .5*iResolution.xy)/min(iResolution.x, iResolution.y);\n"
    "    float tt = iTime*.5;\n"
    "    \n"
    "    uv.xy *= mix(.8, 1.2, SIN(-tt+5.*length(uv.xy)));\n"
    "    \n"
    "    vec3 col = vec3(0);\n"
    "    vec3 rd = vec3(uv, 1);\n"
    "    vec3 p = vec3(0);\n"
    "    float t = .1;\n"
    "    \n"
    "    for(float i=0.; i<120.; i++) {\n"
    "        vec3 p = t*rd + rd;\n"
    "        \n"
    "        float r = length(p);\n"
    "        \n"
    "        float z = p.z;\n"
    "        p.xy *= rot(p.z*.75);\n"
    "      \n"
    "        // log spherical coords\n"
    "        p = vec3(log(r)*.5,\n"
    "            acos(p.z / r),\n"
    "            atan(p.y, p.x));\n"
    "        p = abs(p)-mix(.1, .5, SIN(.2*tt));\n"
    "    \n"
    "        for(float j=0.; j < 3.; j++) {     \n"
    "            float  a= exp(j)/exp2(j);\n"
    "            p += cos(2.*p.yzx*a + .5*tt - length(p.xy)*9.)/a; \n"
    "        }\n"
    "        \n"
    "        float d = 0.007 + abs((exp2(1.4*p)-vec3(0,1.+.7*SIN(tt),0)).y-1.)/14.;\n"
    "        float k = t*.7 +length(p)*.1 - .2*tt + z*.1;\n"
    "        vec3 c = getPal(PALETTE, k);\n"
    "        c = mix(c, c*vec3(0.922,0.973,0.725), SIN(z*.5));\n"
    "        col += c*1e-3/d;       \n"
    "        t += d/4.;\n"
    "    }\n"
    "    \n"
    "    // add glow in the center\n"
    "    float gl = exp(-17.*length(uv.xy));\n"
    "    col += .4*mix(vec3(0.361,0.957,1.000), vec3(0.847,1.000,0.561), SIN(gl*2.-tt))*pow(gl*11., 1.);\n"
    "    \n"
    "    // tone mapping & gamma correction\n"
    "    col *= tanh(col*.1);\n"
    "    col = pow(col, vec3(.45));\n"
    "    \n"
    "    // Apply user color as subtle accent\n"
    "    col = mix(col, col * u_color.rgb, 0.1);\n"
    "    \n"
    "    frag_color = vec4(col, u_color.a).bgra;\n"
    "}\n";


// Shader for Desktop 1 (Starfield)
static const char *desktop_1_fs_src =
    "#version 300 es\n"
    "precision mediump float;\n"
    "in vec2 v_texcoord;\n"
    "out vec4 frag_color;\n"
    "uniform float time;\n"
    "uniform vec2 iResolution;\n"
    "uniform vec4 u_color;\n"
    "#define A 9.\n"
    "#define T (time/3e2)\n"
    "#define H(a) (cos(radians(vec3(180, 90, 0))+(a)*6.2832)*.5+.5)\n"
    "float hash(vec2 p) { return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453); }\n"
    "mat2 rot(float a) { float s=sin(a), c=cos(a); return mat2(c,-s,s,c); }\n"
    "float map(vec3 u, float v) {\n"
    "    float t = T,\n"
    "          l = 5.,\n"
    "          f = 1e10, i = 0., y, z;\n"
    "    u.xy = vec2(atan(u.x, u.y), length(u.xy));\n"
    "    u.x += t*v*3.1416*.7;\n"
    "    for (; i++<l;) {\n"
    "        vec3 p = u;\n"
    "        y = round((p.y-i)/l)*l+i;\n"
    "        p.x *= y;\n"
    "        p.x -= y*y*t*3.1416;\n"
    "        p.x -= round(p.x/6.2832)*6.2832;\n"
    "        p.y -= y;\n"
    "        z = cos(y*t*6.2832)*.5+.5;\n"
    "        f = min(f, max(length(p.xy), -p.z-z*A) -.1 -z*.2 -p.z/1e2);\n"
    "    }\n"
    "    return f;\n"
    "}\n"
    "void main() {\n"
    "    vec2 R = iResolution.xy, j,\n"
    "         U = gl_FragCoord.xy;\n"
    "    vec2 m = vec2(0, .5);\n"
    "    vec3 o = vec3(0, 0, -130.),\n"
    "         u = normalize(vec3(U - R/2., R.y)),\n"
    "         c = vec3(0),\n"
    "         p, k;\n"
    "    float t = T,\n"
    "          v = -o.z/3.,\n"
    "          i = 0., d = i,\n"
    "          s, f, z, r;\n"
    "    bool b;\n"
    "    for (; i++<70.;) {\n"
    "        p = u*d + o;\n"
    "        p.xy /= v;\n"
    "        r = length(p.xy);\n"
    "        z = abs(1.-r*r);\n"
    "        b = r < 1.;\n"
    "        if (b) z = sqrt(z);\n"
    "        p.xy /= z+1.;\n"
    "        p.xy -= m;\n"
    "        p.xy *= v;\n"
    "        p.xy -= cos(p.z/8. +t*3e2 +vec2(0, 1.5708) +z/2.)*.2;\n"
    "        s = map(p, v);\n"
    "        r = length(p.xy);\n"
    "        f = cos(round(r)*t*6.2832)*.5+.5;\n"
    "        k = H(.2 -f/3. +t +p.z/2e2);\n"
    "        if (b) k = 1.-k;\n"
    "        c += min(exp(s/-.05), s)\n"
    "           * (f+.01)\n"
    "           * min(z, 1.)\n"
    "           * sqrt(cos(r*6.2832)*.5+.5)\n"
    "           * k*k;\n"
    "        if (s < 1e-3 || d > 1e3) break;\n"
    "        d += s*clamp(z, .2, .9);\n"
    "    }\n"
    "    c += min(exp(-p.z-f*A)*z*k*.01/s, 1.);\n"
    "    j = p.xy/v+m;\n"
    "    c /= clamp(dot(j, j)*4., .04, 4.);\n"
    "    frag_color = vec4(exp(log(c * u_color.rgb)/2.2), 1.0).bgra;\n"
    "}\n";

// Shader for Desktop 2 (Tunnel)
static const char *desktop_2_fs_src =
    "#version 300 es\n"
    "precision mediump float;\n"
    "in vec2 v_texcoord;\n"
    "out vec4 frag_color;\n"
    "uniform float time;\n"
    "uniform vec2 iResolution;\n"
    "uniform vec4 u_color;\n"
    "const float PI = 3.14159265;\n"
    "vec3 cmap(float x) { return pow(.5+.5*cos(PI * x + vec3(1,2,3)), vec3(2.5)); }\n"
    "void main() {\n"
    "    vec2 fragCoord = gl_FragCoord.xy;\n"
    "    vec2 uv = (2. * fragCoord-iResolution.xy)/iResolution.y;\n"
    "    float focal = 2.25;\n"
    "    vec3 ro = vec3(0,0,time);\n"
    "    vec3 rd = normalize(vec3(uv, -focal));\n"
    "    vec3 color = vec3(0);\n"
    "    float t = 0.;\n"
    "    for(int i = 0; i < 99; i++) {\n"
    "        vec3 p = t * rd + ro;\n"
    "        float T = (t+time)/5.;\n"
    "        float c = cos(T), s = sin(T);\n"
    "        p.xy = mat2(c,-s,s,c) * p.xy;\n"
    "        for(float f = 0.; f < 9.; f++) {\n"
    "            float a = exp(f)/exp2(f);\n"
    "            p += cos(p.yzx * a + time)/a;\n"
    "        }\n"
    "        float d = 1./50. + abs((ro -p-vec3(0,1,0)).y-1.)/10.;\n"
    "        color += cmap(t) * 2e-3 / d;\n"
    "        t += d;\n"
    "    }\n"
    "    color *= color*color;\n"
    "    color = 1.-exp(-color);\n"
    "    color = pow(color, vec3(1./2.2));\n"
    "    frag_color = vec4(color * u_color.rgb, 1.0).bgra;\n"
    "}\n";

// Shader for Desktop 3 (Simple Noise)
static const char *desktop_3_fs_src =
    "#version 300 es\n"
    "precision mediump float;\n"
    "in vec2 v_texcoord;\n"
    "out vec4 frag_color;\n"
    "uniform float time;\n"
    "uniform vec2 iResolution;\n"
    "uniform vec4 u_color;\n"
    "void main() {\n"
    "    vec2 I = gl_FragCoord.xy;\n"
    "    vec4 O = vec4(0.0);\n"
    "    float t = time,\n"
    "          i = 0.0,\n"
    "          z = 0.0,\n"
    "          d,\n"
    "          s;\n"
    "    for(O*=i; i++<1e2; ) {\n"
    "        vec3 p = z * normalize( vec3(I+I,0) - iResolution.xyy );\n"
    "        for(d=5.; d<2e2; d+=d)\n"
    "            p += .6*sin(p.yzx*d - .2*t) / d;\n"
    "        z += d = .005 + max(s=.3-abs(p.y), -s*.2)/4.;\n"
    "        O += (cos(s/.07+p.x+.5*t-vec4(3,4,5,0)) + 1.5) * exp(s/.1) / d;\n"
    "    }\n"
    "    O = tanh(O*O / 4e8);\n"
    "    frag_color = vec4(O.rgb * u_color.rgb, 1.0).bgra;\n"
    "}\n";
//https://www.shadertoy.com/view/3f3SWf
static const char *desktop_4_fs_src = 
    "#version 300 es\n"
    "precision mediump float;\n"
    "in vec2 v_texcoord;\n"
    "out vec4 frag_color;\n"
    "uniform float time;\n"
    "uniform vec2 iResolution;\n"
    "uniform vec4 u_color;\n"
    "void main() {\n"
    "    vec2 C = gl_FragCoord.xy;\n"
    "    vec4 O = vec4(0.0);\n"
    "    float i = 0.0,\n"
    "          d,\n"
    "          t = 0.2 * time,\n"
    "          z = 0.1 * fract(dot(C, sin(C)));\n"
    "    vec4 p, P;\n"
    "    \n"
    "    for (vec2 r = iResolution.xy; ++i < 77.0; z += 0.2 * d + 1e-3) {\n"
    "        p = vec4(z * normalize(vec3(C - 0.5 * r, r.y)), 0.0);\n"
    "        p.xy += 6.0;\n"
    "        p.z += t;\n"
    "        \n"
    "        d = 4.0;\n"
    "        \n"
    "        for (P = p; d < 7.0; d /= 0.8)\n"
    "            p += cos(p.zxyw * d + 0.6 * t) / d;\n"
    "        \n"
    "        P = 1.0 + sin(vec4(0, 1, 2, 0) + 9.0 * length(P - p));\n"
    "        \n"
    "        p -= round(p);\n"
    "        d = abs(min(length(p.yz), min(length(p.xy), length(p.xz))) - 0.1 * tanh(z) + 2e-2);\n"
    "        \n"
    "        O += P.w / max(d, 1e-3) * P;\n"
    "    }\n"
    "    \n"
    "    O = tanh(O / 2e4);\n"
    "    frag_color = vec4(O.rgb * u_color.rgb, 1.0).bgra;\n"
    "}\n";  
    
//https://www.shadertoy.com/view/tf3SWB    
static const char *desktop_5_fs_src = 
    "#version 300 es\n"
    "precision mediump float;\n"
    "in vec2 v_texcoord;\n"
    "out vec4 frag_color;\n"
    "uniform float time;\n"
    "uniform vec2 iResolution;\n"
    "uniform vec4 u_color;\n"
    "void main() {\n"
    "    vec2 C = gl_FragCoord.xy;\n"
    "    vec4 O = vec4(0.0);\n"
    "    float d, s, j, i = 0.0, z = 0.0, N, D, k, t = time;\n"
    "    vec4 o = vec4(0.0), p, U = vec4(3, 1, 2, 0);\n"
    "    \n"
    "    for (vec2 q, r = iResolution.xy; ++i < 70.0; z += 0.5 * d + 1E-3) {\n"
    "        p = vec4(z * normalize(vec3(C - 0.5 * r, r.y)), 0.0);\n"
    "        p.z -= 3.0;\n"
    "        \n"
    "        // Rotation matrix multiplication: p.xz *= mat2(.8,.6,-.8,.6)\n"
    "        vec2 temp = p.xz;\n"
    "        p.x = temp.x * 0.8 + temp.y * 0.6;\n"
    "        p.z = temp.x * (-0.8) + temp.y * 0.6;\n"
    "        \n"
    "        p *= k = 8.0 / dot(p, p);\n"
    "        q = p.xy;\n"
    "        q -= round(q / 5.0) * 5.0;\n"
    "        \n"
    "        // Create rotation matrix R\n"
    "        float angle = 0.5 * t + log2(k) + 11.0 * U.w;\n"
    "        float cos_a = cos(angle);\n"
    "        float sin_a = sin(angle);\n"
    "        mat2 R = mat2(cos_a, sin_a, -sin_a, cos_a);\n"
    "        \n"
    "        d = 1.0;\n"
    "        s = 1.0;\n"
    "        j = 1.0;\n"
    "        \n"
    "        for (; ++j < 6.0; s *= 0.5) {\n"
    "            q = abs(q * R) - 2.0 * s / j;\n"
    "            D = length(q) - s / 8.0;\n"
    "            if (D < d) {\n"
    "                N = j;\n"
    "                d = D;\n"
    "            }\n"
    "        }\n"
    "        \n"
    "        d = abs(d) / k;\n"
    "        p = 1.0 + sin(p.z + U.zywz - t + N);\n"
    "        \n"
    "        o += p.w / max(d, 1E-3) * p + exp(0.3 * k) * 6.0 * U;\n"
    "    }\n"
    "    \n"
    "    O = tanh(o / 3e4);\n"
    "    frag_color = vec4(O.rgb * u_color.rgb, 1.0).bgra;\n"
    "}\n"; 

// https://www.shadertoy.com/view/w32XDc
static const char *desktop_6_fs_src = 
    "#version 300 es\n"
    "precision mediump float;\n"
    "in vec2 v_texcoord;\n"
    "out vec4 frag_color;\n"
    "uniform float time;\n"
    "uniform vec2 iResolution;\n"
    "uniform vec4 u_color;\n"
    "\n"
    "/*\n"
    "    See here for how to do a tiny raymarch loop and translucency:\n"
    "        https://www.shadertoy.com/view/wXjSRt\n"
    "        https://www.shadertoy.com/view/wXSXzV\n"
    "        \n"
    "    See here for how to do a basic tunnel:\n"
    "        https://www.shadertoy.com/view/Wcf3D7\n"
    "        \n"
    "    Converted to OpenGL ES 3.0\n"
    "*/\n"
    "\n"
    "#define iTime time\n"
    "#define P(z) vec3(cos(vec2(.15,.2)*(z))*5.,z)\n"
    "\n"
    "void main() {\n"
    "    vec2 u = gl_FragCoord.xy;\n"
    "    vec4 o = vec4(0.0);\n"
    "    float i = 0.0, d = 0.0, s = 0.0, n = 0.0, t = iTime * 3.0;\n"
    "    vec3 q = vec3(iResolution, 0.0);\n"
    "    vec3 p = P(t);\n"
    "    vec3 Z = normalize(P(t + 1.0) - p);\n"
    "    vec3 X = normalize(vec3(Z.z, 0.0, -Z.x));\n"
    "    vec3 D = vec3((u - q.xy / 2.0) / q.y, 1.0) * mat3(-X, cross(X, Z), Z);\n"
    "    \n"
    "    for(o *= i; i < 100.0; i++) {\n"
    "        p += D * s;\n"
    "        q = P(p.z) + cos(t + p.yzx) * 0.3;\n"
    "        s = 2.0 - min(length((p - q).xy),\n"
    "                 min(length(p.xy - vec2(q.y)),\n"
    "                     length(p.xy - vec2(q.x))));\n"
    "        \n"
    "        for (n = 0.1; n < 1.0; n += n) {\n"
    "            s -= abs(dot(sin(p * n * 16.0), vec3(0.03))) / n;\n"
    "        }\n"
    "        \n"
    "        d += s = 0.04 + abs(s) * 0.2;\n"
    "        o += (1.0 + cos(d + vec4(4.0, 2.0, 1.0, 0.0))) / s / d;\n"
    "    }\n"
    "    \n"
    "    o = tanh(o / 200.0);\n"
    "    frag_color = vec4(o.rgb * u_color.rgb, 1.0);\n"
    "}\n";
    
    
// https://www.shadertoy.com/view/XcS3zK
static const char *desktop_7_fs_src = 
    "#version 300 es\n"
    "precision mediump float;\n"
    "in vec2 v_texcoord;\n"
    "out vec4 frag_color;\n"
    "uniform float time;\n"
    "uniform vec2 iResolution;\n"
    "uniform vec4 u_color;\n"
    "\n"
    "/* Shading constants */\n"
    "const vec3 LP = vec3(-0.6, 0.7, -0.3);\n"
    "const vec3 LC = vec3(0.85, 0.80, 0.70);\n"
    "const vec3 HC1 = vec3(0.5, 0.4, 0.3);\n"
    "const vec3 HC2 = vec3(0.1, 0.1, 0.6) * 0.5;\n"
    "const vec3 HLD = vec3(0.0, 1.0, 0.0);\n"
    "const vec3 BC = vec3(0.25, 0.25, 0.25);\n"
    "const vec3 FC = vec3(1.30, 1.20, 1.00);\n"
    "const float AS = 0.5;\n"
    "const float DS = 1.0;\n"
    "const float BS = 0.3;\n"
    "const float FS = 0.3;\n"
    "\n"
    "/* Raymarching constants */\n"
    "const float MAX_TRACE_DISTANCE = 10.0;\n"
    "const float INTERSECTION_PRECISION = 0.0001;\n"
    "const int NUM_OF_TRACE_STEPS = 64;\n"
    "const float STEP_MULTIPLIER = 1.0;\n"
    "\n"
    "/* Structures */\n"
    "struct Camera {\n"
    "    vec3 ro;\n"
    "    vec3 rd;\n"
    "    vec3 forward;\n"
    "    vec3 right;\n"
    "    vec3 up;\n"
    "    float FOV;\n"
    "};\n"
    "\n"
    "struct Surface {\n"
    "    float len;\n"
    "    vec3 position;\n"
    "    vec3 colour;\n"
    "    float id;\n"
    "    float steps;\n"
    "    float AO;\n"
    "};\n"
    "\n"
    "struct Model {\n"
    "    float dist;\n"
    "    vec3 colour;\n"
    "    float id;\n"
    "};\n"
    "\n"
    "/* Utilities */\n"
    "vec2 toScreenspace(in vec2 p) {\n"
    "    vec2 uv = (p - 0.5 * iResolution.xy) / min(iResolution.y, iResolution.x);\n"
    "    return uv;\n"
    "}\n"
    "\n"
    "mat2 R(float a) {\n"
    "    float c = cos(a);\n"
    "    float s = sin(a);\n"
    "    return mat2(c, -s, s, c);\n"
    "}\n"
    "\n"
    "Camera getCamera(in vec2 uv, in vec3 pos, in vec3 target) {\n"
    "    vec3 f = normalize(target - pos);\n"
    "    vec3 r = normalize(vec3(f.z, 0.0, -f.x));\n"
    "    vec3 u = normalize(cross(f, r));\n"
    "    \n"
    "    float FOV = 1.0 + cos(time * 0.1) * 0.8;\n"
    "    \n"
    "    return Camera(pos, normalize(f + FOV * uv.x * r + FOV * uv.y * u), f, r, u, FOV);\n"
    "}\n"
    "\n"
    "/* Modelling */\n"
    "float G(vec3 p) {\n"
    "    return dot(sin(p.yzx), cos(p.zxy));\n"
    "}\n"
    "\n"
    "Model model(vec3 p) {\n"
    "    float t = time * 0.1;\n"
    "    p.xz *= R(t);\n"
    "    p.xy *= R(0.3);\n"
    "    p.xy -= 0.5;\n"
    "    float d = abs(-(length(vec2(p.y, length(p.xz) - 2.0)) - 1.8 + cos(t) * 0.3));\n"
    "    \n"
    "    float g = G(p.yxz * 4.0) / 4.0;\n"
    "    \n"
    "    d = length(vec2(d, g)) - 0.3;\n"
    "    vec3 colour = vec3(g);\n"
    "    \n"
    "    return Model(d, colour, 1.0);\n"
    "}\n"
    "\n"
    "Model map(vec3 p) {\n"
    "    return model(p);\n"
    "}\n"
    "\n"
    "vec3 calcNormal(in vec3 pos) {\n"
    "    vec3 eps = vec3(0.001, 0.0, 0.0);\n"
    "    vec3 nor = vec3(\n"
    "        map(pos + eps.xyy).dist - map(pos - eps.xyy).dist,\n"
    "        map(pos + eps.yxy).dist - map(pos - eps.yxy).dist,\n"
    "        map(pos + eps.yyx).dist - map(pos - eps.yyx).dist\n"
    "    );\n"
    "    return normalize(nor);\n"
    "}\n"
    "\n"
    "/* Raymarcher */\n"
    "Surface march(in Camera cam) {\n"
    "    float h = 1e4;\n"
    "    float d = 0.0;\n"
    "    float id = -1.0;\n"
    "    float s = 0.0;\n"
    "    float ao = 0.0;\n"
    "    vec3 p;\n"
    "    vec3 c;\n"
    "\n"
    "    for (int i = 0; i < NUM_OF_TRACE_STEPS; i++) {\n"
    "        if (abs(h) < INTERSECTION_PRECISION || d > MAX_TRACE_DISTANCE) break;\n"
    "        p = cam.ro + cam.rd * d;\n"
    "        Model m = map(p);\n"
    "        h = m.dist;\n"
    "        d += h * STEP_MULTIPLIER;\n"
    "        id = m.id;\n"
    "        s += 1.0;\n"
    "        ao += max(h, 0.0);\n"
    "        c = m.colour;\n"
    "    }\n"
    "\n"
    "    if (d >= MAX_TRACE_DISTANCE) id = -1.0;\n"
    "\n"
    "    return Surface(d, p, c, id, s, ao);\n"
    "}\n"
    "\n"
    "/* Shading */\n"
    "float softshadow(in vec3 ro, in vec3 rd, in float mint, in float tmax) {\n"
    "    float res = 1.0;\n"
    "    float t = mint;\n"
    "    for (int i = 0; i < 16; i++) {\n"
    "        float h = map(ro + rd * t).dist;\n"
    "        res = min(res, 8.0 * h / t);\n"
    "        t += clamp(h, 0.02, 0.10);\n"
    "        if (h < 0.001 || t > tmax) break;\n"
    "    }\n"
    "    return clamp(res, 0.0, 1.0);\n"
    "}\n"
    "\n"
    "float AO(in vec3 pos, in vec3 nor) {\n"
    "    float occ = 0.0;\n"
    "    float sca = 1.0;\n"
    "    for (int i = 0; i < 5; i++) {\n"
    "        float hr = 0.01 + 0.12 * float(i) / 4.0;\n"
    "        vec3 aopos = nor * hr + pos;\n"
    "        float dd = map(aopos).dist;\n"
    "        occ += -(dd - hr) * sca;\n"
    "        sca *= 0.95;\n"
    "    }\n"
    "    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n"
    "}\n"
    "\n"
    "vec3 shade(vec3 col, vec3 pos, vec3 nor, vec3 ref, Camera cam) {\n"
    "    vec3 plp = LP - pos;\n"
    "    \n"
    "    float o = AO(pos, nor);\n"
    "    vec3 l = normalize(plp);\n"
    "    \n"
    "    float d = clamp(dot(nor, l), 0.0, 1.0) * DS;\n"
    "    float b = clamp(dot(nor, normalize(vec3(-l.x, 0.0, -l.z))), 0.0, 1.0) * clamp(1.0 - pos.y, 0.0, 1.0) * BS;\n"
    "    float f = pow(clamp(1.0 + dot(nor, cam.rd), 0.0, 1.0), 2.0) * FS;\n"
    "\n"
    "    vec3 c = vec3(0.0);\n"
    "    c += d * LC;\n"
    "    c += mix(HC1, HC2, dot(nor, HLD)) * AS;\n"
    "    c += b * BC * o;\n"
    "    c += f * FC * o;\n"
    "    \n"
    "    return col * c;\n"
    "}\n"
    "\n"
    "vec3 render(Surface surface, Camera cam, vec2 uv) {\n"
    "    vec3 colour = vec3(0.04, 0.045, 0.05);\n"
    "    colour = vec3(0.35, 0.5, 0.75);\n"
    "    vec3 colourB = vec3(0.9, 0.85, 0.8);\n"
    "    \n"
    "    colour = mix(colourB, colour, pow(length(uv), 2.0) / 1.5);\n"
    "\n"
    "    if (surface.id > -1.0) {\n"
    "        vec3 surfaceNormal = calcNormal(surface.position);\n"
    "        vec3 ref = reflect(cam.rd, surfaceNormal);\n"
    "        colour = surfaceNormal;\n"
    "        vec3 pos = surface.position;\n"
    "        \n"
    "        float t = time;\n"
    "        vec3 col = mix(\n"
    "            mix(\n"
    "                vec3(0.8, 0.3, 0.6),\n" 
    "                vec3(0.6, 0.3, 0.8),\n"
    "                dot(surfaceNormal, surfaceNormal.zxy)\n"
    "            ),\n"
    "            vec3(1.0),\n"
    "            smoothstep(0.0, 0.1, cos(surface.colour.r * 40.0))\n"
    "        );\n"
    "        \n"
    "        colour = shade(col, pos, surfaceNormal, ref, cam);\n"
    "    }\n"
    "\n"
    "    return colour;\n"
    "}\n"
    "\n"
    "void main() {\n"
    "    vec3 c = vec3(0.0);\n"
    "    for (int x = 0; x < 2; x++) {\n"
    "        for (int y = 0; y < 2; y++) {\n"
    "            vec2 uv = toScreenspace(gl_FragCoord.xy + vec2(float(x), float(y)) * 0.5);\n"
    "\n"
    "            Camera cam = getCamera(uv, vec3(1.5, 0.0, 1.5), vec3(0.0));\n"
    "            Surface surface = march(cam);\n"
    "\n"
    "            c += render(surface, cam, uv);\n"
    "        }\n"
    "    }\n"
    "    \n"
    "    vec4 final_color = vec4(c * 0.25, 1.0);\n"
    "    frag_color = vec4(final_color.rgb * u_color.rgb, 1.0).bgra;\n"
    "}\n"; 
    
    
// https://www.shadertoy.com/view/Wc3SDX
static const char *desktop_8_fs_src =
    "#version 300 es\n"
    "precision mediump float;\n"
    "in vec2 v_texcoord;\n"
    "out vec4 frag_color;\n"
    "uniform float time;\n"
    "uniform vec2 iResolution;\n"
    "uniform vec4 u_color;\n"
    "void main() {\n"
    "    vec2 C = gl_FragCoord.xy;\n"
    "    vec4 O = vec4(0.0);\n"
    "    float i = 0.0, d, z = 0.0, k, c, t = time;\n"
    "    vec4 o = vec4(0.0), p;\n"
    "    \n"
    "    // Create rotation matrix\n"
    "    mat2 R = mat2(cos(0.2*t), -sin(0.2*t), sin(0.2*t), cos(0.2*t));\n"
    "    \n"
    "    for(; i < 80.0; i += 1.0) {\n"
    "        z += 0.7*d + 1e-3;\n"
    "        \n"
    "        // Ray setup\n"
    "        p = vec4(z*normalize(vec3(C+C,0.0)-iResolution.xyy), 0.0);\n"
    "        \n"
    "        // Transform the 3D point\n"
    "        p.z += 3.5;\n"
    "        \n"
    "        // Apply 4D rotation using 2D rotation matrices\n"
    "        vec2 temp_xw = vec2(p.x, p.w);\n"
    "        temp_xw = R * temp_xw;\n"
    "        p.x = temp_xw.x; p.w = temp_xw.y;\n"
    "        \n"
    "        vec2 temp_wy = vec2(p.w, p.y);\n"
    "        temp_wy = R * temp_wy;\n"
    "        p.w = temp_wy.x; p.y = temp_wy.y;\n"
    "        \n"
    "        vec2 temp_zw = vec2(p.z, p.w);\n"
    "        temp_zw = R * temp_zw;\n"
    "        p.z = temp_zw.x; p.w = temp_zw.y;\n"
    "        \n"
    "        // Distance to bounding sphere\n"
    "        c = length(p) - 3.0;\n"
    "        \n"
    "        // Inversion\n"
    "        k = 9.0 / dot(p,p);\n"
    "        p *= k;\n"
    "        \n"
    "        // Create repeating pattern\n"
    "        p += 0.5*t;\n"
    "        p -= floor(p + 0.5);\n"
    "        \n"
    "        // Create rounded hypercube shapes\n"
    "        p *= p;  // p\n"
    "        p *= p;  // p\n"
    "        \n"
    "        // Distance estimation\n"
    "        d = max(abs(pow(dot(p,p), 0.125) - 0.4) / k, c);\n"
    "        \n"
    "        // Lighting/coloring\n"
    "        vec4 color_mult = 1.0 + sin(vec4(5,6,7,5) + 2.0*log2(k));\n"
    "        o += color_mult.w / max(d, 1e-3) * color_mult;\n"
    "    }\n"
    "    \n"
    "    // Tone mapping\n"
    "    O = tanh(o / 2e4);\n"
    "    frag_color = vec4(O.rgb * u_color.rgb, 1.0).bgra;\n"
    "}\n";
    
// https://www.shadertoy.com/view/tcdXzf
static const char *desktop_9_fs_src =
    "#version 300 es\n"
    "precision mediump float;\n"
    "in vec2 v_texcoord;\n"
    "out vec4 frag_color;\n"
    "uniform float time;\n"
    "uniform vec2 iResolution;\n"
    "uniform vec4 u_color;\n"
    "void main() {\n"
    "    vec2 C = gl_FragCoord.xy;\n"
    "    vec4 O = vec4(0.0);\n"
    "    float i = 0.0, d, z = 0.0;\n"
    "    vec4 o = vec4(0.0), p, P, D;\n"
    "    vec2 r = iResolution.xy;\n"
    "    \n"
    "    for(; i < 77.0; i += 1.0) {\n"
    "        z += 0.7*d + 1e-3;\n"
    "        \n"
    "        // Create ray from camera through current pixel\n"
    "        p = vec4(z * normalize(vec3(C - 0.5*r, r.y)), 0.0);\n"
    "        \n"
    "        // Animate scene by moving along Z axis over time\n"
    "        p.z += 0.5*time;\n"
    "        \n"
    "        // 2D rotation matrix to twist the space\n"
    "        float angle = 0.3*p.z;\n"
    "        mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n"
    "        p.xy = rot * p.xy;\n"
    "        \n"
    "        // Center the coordinate system\n"
    "        p.xy -= 0.5;\n"
    "        \n"
    "        // Save original position for lighting calculations\n"
    "        P = p;\n"
    "        \n"
    "        // Create infinite repetition\n"
    "        p = abs(p - floor(p + 0.5));\n"
    "        \n"
    "        // Scale position for surface detail distortion\n"
    "        D = 25.0 * p;\n"
    "        \n"
    "        // Calculate distance to nearest surface using two shapes:\n"
    "        float shape1 = min(p.x, p.y) + 4e-3 + 0.05*sin(D.x)*sin(D.y)*sin(D.z);\n"
    "        float shape2 = min(length(p.zy), min(length(p.xy), length(p.xz))) - 0.1;\n"
    "        d = abs(min(shape1, shape2));\n"
    "        \n"
    "        // Calculate color based on original position\n"
    "        vec4 color_base = 1.0 + sin(0.5*P.z + 5.0*P.y + vec4(0,1,2,0));\n"
    "        \n"
    "        // Accumulate color\n"
    "        o += color_base.w * color_base / max(d, 1e-3);\n"
    "    }\n"
    "    \n"
    "    // Tone mapping\n"
    "    O = tanh(o / 2e4);\n"
    "    frag_color = vec4(O.rgb * u_color.rgb, 1.0).bgra;\n"
    "}\n";
    
    
// https://www.shadertoy.com/view/MfjyWK
static const char *desktop_10_fs_src =
    "#version 300 es\n"
    "precision mediump float;\n"
    "in vec2 v_texcoord;\n"
    "out vec4 frag_color;\n"
    "uniform float time;\n"
    "uniform vec2 iResolution;\n"
    "uniform vec4 u_color;\n"
    "\n"
    "const float pi = 3.14159265359;\n"
    "const float tau = 6.28318530718;\n"
    "const float planeDist = 0.5;\n"
    "const float furthest = 16.0;\n"
    "const float fadeFrom = 8.0;\n"
    "const vec2 pathA = vec2(0.31, 0.41);\n"
    "const vec2 pathB = vec2(1.0, 0.7071067812);\n"
    "const vec4 U = vec4(0, 1, 2, 3);\n"
    "\n"
    "mat2 ROT(float a) {\n"
    "    return mat2(cos(a), sin(a), -sin(a), cos(a));\n"
    "}\n"
    "\n"
    "vec3 aces_approx(vec3 v) {\n"
    "    v = max(v, 0.0);\n"
    "    v *= 0.6;\n"
    "    float a = 2.51;\n"
    "    float b = 0.03;\n"
    "    float c = 2.43;\n"
    "    float d = 0.59;\n"
    "    float e = 0.14;\n"
    "    return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0, 1.0);\n"
    "}\n"
    "\n"
    "vec3 offset(float z) {\n"
    "    return vec3(pathB*sin(pathA*z), z);\n"
    "}\n"
    "\n"
    "vec3 doffset(float z) {\n"
    "    return vec3(pathA*pathB*cos(pathA*z), 1.0);\n"
    "}\n"
    "\n"
    "vec3 ddoffset(float z) {\n"
    "    return vec3(-pathA*pathA*pathB*sin(pathA*z), 0.0);\n"
    "}\n"
    "\n"
    "vec4 alphaBlend(vec4 back, vec4 front) {\n"
    "    float w = front.w + back.w*(1.0-front.w);\n"
    "    vec3 xyz = (front.xyz*front.w + back.xyz*back.w*(1.0-front.w))/w;\n"
    "    return w > 0.0 ? vec4(xyz, w) : vec4(0.0);\n"
    "}\n"
    "\n"
    "float pmin(float a, float b, float k) {\n"
    "    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n"
    "    return mix(b, a, h) - k*h*(1.0-h);\n"
    "}\n"
    "\n"
    "float pmax(float a, float b, float k) {\n"
    "    return -pmin(-a, -b, k);\n"
    "}\n"
    "\n"
    "float pabs(float a, float k) {\n"
    "    return -pmin(a, -a, k);\n"
    "}\n"
    "\n"
    "float star5(vec2 p, float r, float rf, float sm) {\n"
    "    p = -p;\n"
    "    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n"
    "    const vec2 k2 = vec2(-k1.x, k1.y);\n"
    "    p.x = abs(p.x);\n"
    "    p -= 2.0*max(dot(k1,p),0.0)*k1;\n"
    "    p -= 2.0*max(dot(k2,p),0.0)*k2;\n"
    "    p.x = pabs(p.x, sm);\n"
    "    p.y -= r;\n"
    "    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n"
    "    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n"
    "    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n"
    "}\n"
    "\n"
    "vec3 palette(float n) {\n"
    "    return 0.5+0.5*sin(vec3(0.,1.,2.)+n);\n"
    "}\n"
    "\n"
    "vec4 plane(vec3 ro, vec3 rd, vec3 pp, vec3 npp, float pd, vec3 cp, vec3 off, float n) {\n"
    "    float aa = 3.0*pd*distance(pp.xy, npp.xy);\n"
    "    vec4 col = vec4(0.0);\n"
    "    vec2 p2 = pp.xy;\n"
    "    p2 -= offset(pp.z).xy;\n"
    "    vec2 doff = ddoffset(pp.z).xz;\n"
    "    vec2 ddoff = doffset(pp.z).xz;\n"
    "    float dd = dot(doff, ddoff);\n"
    "    p2 = ROT(dd*pi*5.0) * p2;\n"
    "\n"
    "    float d0 = star5(p2, 0.45, 1.6, 0.2) - 0.02;\n"
    "    float d1 = d0 - 0.01;\n"
    "    float d2 = length(p2);\n"
    "    const float colp = pi*100.0;\n"
    "    float colaa = aa*200.0;\n"
    "    \n"
    "    col.xyz = palette(0.5*n+2.0*d2)*mix(0.5/(d2*d2), 1.0, smoothstep(-0.5+colaa, 0.5+colaa, sin(d2*colp)))/max(3.0*d2*d2, 1e-1);\n"
    "    col.xyz = mix(col.xyz, vec3(2.0), smoothstep(aa, -aa, d1));\n"
    "    col.w = smoothstep(aa, -aa, -d0);\n"
    "    return col;\n"
    "}\n"
    "\n"
    "vec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {\n"
    "    float lp = length(p);\n"
    "    vec2 np = p + 1.0/iResolution.xy;\n"
    "    float rdd = 2.0-0.25;\n"
    "    \n"
    "    vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n"
    "    vec3 nrd = normalize(np.x*uu + np.y*vv + rdd*ww);\n"
    "\n"
    "    float nz = floor(ro.z / planeDist);\n"
    "\n"
    "    vec4 acol = vec4(0.0);\n"
    "    vec3 aro = ro;\n"
    "    float apd = 0.0;\n"
    "\n"
    "    for (float i = 1.0; i <= furthest; i += 1.0) {\n"
    "        if (acol.w > 0.95) {\n"
    "            break;\n"
    "        }\n"
    "        float pz = planeDist*nz + planeDist*i;\n"
    "\n"
    "        float lpd = (pz - aro.z)/rd.z;\n"
    "        float npd = (pz - aro.z)/nrd.z;\n"
    "        float cpd = (pz - aro.z)/ww.z;\n"
    "\n"
    "        vec3 pp = aro + rd*lpd;\n"
    "        vec3 npp = aro + nrd*npd;\n"
    "        vec3 cp = aro+ww*cpd;\n"
    "\n"
    "        apd += lpd;\n"
    "\n"
    "        vec3 off = offset(pp.z);\n"
    "\n"
    "        float dz = pp.z-ro.z;\n"
    "        float fadeIn = smoothstep(planeDist*furthest, planeDist*fadeFrom, dz);\n"
    "        float fadeOut = smoothstep(0.0, planeDist*0.1, dz);\n"
    "        float fadeOutRI = smoothstep(0.0, planeDist*1.0, dz);\n"
    "\n"
    "        float ri = mix(1.0, 0.9, fadeOutRI*fadeIn);\n"
    "\n"
    "        vec4 pcol = plane(ro, rd, pp, npp, apd, cp, off, nz+i);\n"
    "\n"
    "        pcol.w *= fadeOut*fadeIn;\n"
    "        acol = alphaBlend(pcol, acol);\n"
    "        aro = pp;\n"
    "    }\n"
    "\n"
    "    return acol.xyz*acol.w;\n"
    "}\n"
    "\n"
    "void main() {\n"
    "    vec2 r = iResolution.xy;\n"
    "    vec2 fragCoord = gl_FragCoord.xy;\n"
    "    vec2 q = fragCoord/r;\n"
    "    vec2 pp = -1.0+2.0*q;\n"
    "    vec2 p = pp;\n"
    "    p.x *= r.x/r.y;\n"
    "\n"
    "    float tm = planeDist*time;\n"
    "\n"
    "    vec3 ro = offset(tm);\n"
    "    vec3 dro = doffset(tm);\n"
    "    vec3 ddro = ddoffset(tm);\n"
    "\n"
    "    vec3 ww = normalize(dro);\n"
    "    vec3 uu = normalize(cross(U.xyx+ddro, ww));\n"
    "    vec3 vv = cross(ww, uu);\n"
    "    \n"
    "    vec3 col = color(ww, uu, vv, ro, p);\n"
    "    col = aces_approx(col);\n"
    "    col = sqrt(col);\n"
    "    frag_color = vec4(col * u_color.rgb, 1.0).bgra;\n"
    "}\n";
    
    
// https://www.shadertoy.com/view/wXSXzV
static const char *desktop_11_fs_src =
    "#version 300 es\n"
    "precision mediump float;\n"
    "in vec2 v_texcoord;\n"
    "out vec4 frag_color;\n"
    "uniform float time;\n"
    "uniform vec2 iResolution;\n"
    "uniform vec4 u_color;\n"
    "void main() {\n"
    "    vec2 I = gl_FragCoord.xy;\n"
    "    vec4 O = vec4(0.0);\n"
    "    float t = time, i = 0.0, z = 0.0, d, s;\n"
    "    \n"
    "    for(; i < 1e2; i += 1.0) {\n"
    "        vec3 p = z * normalize(vec3(I+I, 0.0) - iResolution.xyy);\n"
    "        p.z -= t;\n"
    "        \n"
    "        for(d = 1.0; d < 64.0; d += d) {\n"
    "            p += 0.7 * cos(p.yzx * d) / d;\n"
    "        }\n"
    "        \n"
    "        float angle = z * 0.2;\n"
    "        mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n"
    "        p.xy = rot * p.xy;\n"
    "        \n"
    "        s = 3.0 - abs(p.x);\n"
    "        d = 0.03 + 0.1 * max(s, -s * 0.2);\n"
    "        z += d;\n"
    "        \n"
    "        vec4 color_contrib = (cos(s + s - vec4(5,0,1,3)) + 1.4) / d / z;\n"
    "        O += color_contrib;\n"
    "    }\n"
    "    \n"
    "    O = tanh(O * O / 4e5);\n"
    "    frag_color = vec4(O.rgb * u_color.rgb, 1.0).bgra;\n"
    "}\n"; 

// https://www.shadertoy.com/view/3fK3D1
static const char *desktop_12_fs_src =
    "#version 300 es\n"
    "precision mediump float;\n"
    "in vec2 v_texcoord;\n"
    "out vec4 frag_color;\n"
    "uniform float time;\n"
    "uniform vec2 iResolution;\n"
    "uniform vec4 u_color;\n"
    "void main() {\n"
    "    vec2 u = gl_FragCoord.xy;\n"
    "    vec4 o = vec4(0.0);\n"
    "    vec3 p = vec3(iResolution, 0.0);\n"
    "    u = (u - p.xy/2.0) / p.y * 0.6;\n"
    "    \n"
    "    float i = 0.0, d = 0.0, s, n;\n"
    "    float t = time * 0.05 + 2.0;\n"
    "    float a = atan(u.x, u.y);\n"
    "    \n"
    "    for(; i < 1e2; i += 1.0) {\n"
    "        p = vec3(u * d, d + t * 4.0);\n"
    "        p += cos(p.z + t + p.yzx * 0.5) * 0.5;\n"
    "        s = 5.0 - length(p.xy);\n"
    "        \n"
    "        for(n = 0.06; n < 2.0; n += n) {\n"
    "            float angle = t * 0.1;\n"
    "            mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n"
    "            p.xy = rot * p.xy;\n"
    "            s -= abs(dot(sin(p.z + t + p * n * 20.0), vec3(0.05))) / n;\n"
    "        }\n"
    "        \n"
    "        d += s = 0.02 + abs(s) * 0.1;\n"
    "        \n"
    "        // Colorful version with base reddish color and angle-based coloring\n"
    "        vec4 c = cos(vec4(a - t + 1.0, a + a - t * 0.8 + 5.0, d * 1.5 + t * 1.4 + 2.0, d + t * 3.0 + 4.0)) + 1.0;\n"
    "        o += d * 0.05 * vec4(4.0, 1.0, 1.0, 0.0) / length(u) / s;\n"
    "        o.yz += c.xy * vec2(c.z, c.w + 0.5) * 1.5 / s;\n"
    "    }\n"
    "    \n"
    "    o = tanh(o / d / 9e2);\n"
    "    frag_color = vec4(o.rgb * u_color.rgb, 1.0).bgra;\n"
    "}\n";


// https://www.shadertoy.com/view/43VcD3
static const char *desktop_13_fs_src = 
    "#version 300 es\n"
    "precision mediump float;\n"
    "in vec2 v_texcoord;\n"
    "out vec4 frag_color;\n"
    "uniform float time;\n"
    "uniform vec2 iResolution;\n"
    "uniform vec4 u_color;\n"
    "\n"
    "#define PI 3.141592\n"
    "#define TAU (2.*PI)\n"
    "#define SIN(x) (sin(x)*.5+.5)\n"
    "#define BUMP_EPS 0.004\n"
    "#define sabsk(x, k) sqrt(x * x + k * k)\n"
    "#define sabs(x) (sabsk(x, .1))\n"
    "#define S(a, b, x) smoothstep(a, b, x)\n"
    "\n"
    "float tt, g_mat;\n"
    "vec3 ro;\n"
    "\n"
    "mat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }\n"
    "\n"
    "float smin(float a, float b, float k) {\n"
    "  float h = clamp((a-b)/k * .5 + .5, 0.0, 1.0);\n"
    "  return mix(a, b, h) - h*(1.-h)*k;\n"
    "}\n"
    "\n"
    "float pMod(float p, float size) {\n"
    "	float halfsize = size*0.5;\n"
    "	float c = floor((p + halfsize)/size);\n"
    "	p = mod(p + halfsize, size) - halfsize;\n"
    "	return p;\n"
    "}\n"
    "\n"
    "float n21(vec2 p) {\n"
    "      return fract(sin(dot(p, vec2(524.423, 123.34)))*3228324.345);\n"
    "}\n"
    "\n"
    "float noise(vec2 n) {\n"
    "    const vec2 d = vec2(0., 1.0);\n"
    "    vec2 b = floor(n);\n"
    "    vec2 f = mix(vec2(0.0), vec2(1.0), fract(n));\n"
    "    return mix(mix(n21(b), n21(b + d.yx), f.x), mix(n21(b + d.xy), n21(b + d.yy), f.x), f.y);\n"
    "}\n"
    "\n"
    "vec3 g_p;\n"
    "float smax( float a, float b, float k )\n"
    "{\n"
    "    float h = max(k-abs(a-b),0.0);\n"
    "    return max(a, b) + h*h*0.25/k;\n"
    "}\n"
    "\n"
    "vec3 fold(vec3 p) {\n"
    "    float c = cos(PI/5.), s = sqrt(.75 - c*c);\n"
    "    vec3 n = vec3(-.5, -c, s);\n"
    "    p = abs(p);;\n"
    "    p -= 2.*min(0., dot(p, n))*n;\n"
    "    p.xy = abs(p.xy);\n"
    "    p -= 2.*min(0., dot(p, n))*n;\n"
    "    p.xy = abs(p.xy);\n"
    "    p -= 2.*min(0., dot(p, n))*n;\n"
    "    return p;\n"
    "}\n"
    "\n"
    "vec4 inverseStereographic(vec3 p, out float k) {\n"
    "    k = 2.0/(1.0+dot(p,p));\n"
    "    return vec4(k*p,k-1.0);\n"
    "}\n"
    "\n"
    "float fTorus(vec4 p4) {\n"
    "    float d1 = length(p4.xy) / length(p4.zw) - 1.;\n"
    "    float d2 = length(p4.zw) / length(p4.xy) - 1.;\n"
    "    float d = d1 < 0. ? -d1 : d2;\n"
    "    d /= PI;\n"
    "    return d;\n"
    "}\n"
    "\n"
    "float fixDistance(float d, float k) {\n"
    "    float sn = sign(d);\n"
    "    d = abs(d);\n"
    "    d = d / k * 1.82;\n"
    "    d += 1.;\n"
    "    d = pow(d, .5);\n"
    "    d -= 1.;\n"
    "    d *= 5./3.;\n"
    "    d *= sn;\n"
    "    return d;\n"
    "}\n"
    "\n"
    "float map(vec3 p) {\n"
    "    p.xy *= rot(.1*tt);\n"
    "    p.xz *= rot(.3*tt);\n"
    "    vec3 bp0 = p;\n"
    "    p = fold(p);\n"
    "    vec3 bp = p;\n"
    "    float k;\n"
    "    p = bp0;\n"
    "    p.x = sabsk(p.x, 1.2) - 2.;\n"
    "    p.xy *= rot(p.z*.3+tt);\n"
    "    vec4 p4 = inverseStereographic(p,k);\n"
    "    p4.y -= SIN(.3*tt);\n"
    "    p4.zy *= rot(tt*.5);\n"
    "    p4.xw *= rot(tt*.5);\n"
    "    float d = fTorus(p4);\n"
    "    d = abs(d);\n"
    "    d -= .2;\n"
    "    d = fixDistance(d, k);\n"
    "    p = bp;\n"
    "    p.xy *= rot(1.*p.z*.5+tt);\n"
    "    p.xz *= rot(.5*p.y+.5*tt);\n"
    "    p.xy -= sin(p.z*mix(2., 15., SIN(.7*tt))+tt)*.2;\n"
    "    bp = p;\n"
    "    p.x -= .3;\n"
    "    p.xz = sabsk(p.xz, .4) - .5*SIN(tt);\n"
    "    p.xz*= rot(tt);\n"
    "    p.xz -= vec2(sin(.4*tt)*.3, cos(.3*tt)*.4);\n"
    "    float d1 = length(p) - 1.4;\n"
    "    p = bp;\n"
    "    p.x += .8;\n"
    "    p.xy = sabsk(p.xy, .4) + 1.*SIN(.5*tt);\n"
    "    p.xz += vec2(sin(tt)*.4, cos(tt)*1.5);\n"
    "    float d2 = smax(d1, -(length(p) - 1.4), 1.);\n"
    "    d = smax(d, (d2)-.5, .5);\n"
    "    return d*.8;\n"
    "}\n"
    "\n"
    "vec3 pal(float x) {\n"
    "    return .5 + .5*cos( 6.28318*(vec3(1.0,1.0,1.0)*x+vec3(0.0,0.3,0.5)));\n"
    "}\n"
    "\n"
    "vec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n"
    "    vec3 f = normalize(l - p),\n"
    "         r = normalize(cross(vec3(0, 1, 0), f)),\n"
    "         u = cross(f, r),\n"
    "         c = p + f * z,\n"
    "         i = c + uv.x * r + uv.y * u,\n"
    "         rd = normalize(i - p);\n"
    "    return rd;\n"
    "}\n"
    "\n"
    "void main() {\n"
    "    vec2 uv = (gl_FragCoord.xy - .5*iResolution.xy)/iResolution.y;\n"
    "    tt = time + 30.;\n"
    "    vec3 col;\n"
    "    ro = vec3(.0, 0, -4);\n"
    "    vec3 lookat = vec3(0, 0, 0), p;\n"
    "    vec3 rd = getRayDir(uv, ro, lookat, 1.);\n"
    "    float mat = 0.,\n"
    "          t   = 0.,\n"
    "          d   = 0.;\n"
    "    float alpha = 0.;\n"
    "    p = ro;\n"
    "    float MAX_DIST = 15.;\n"
    "    vec3 c;\n"
    "    for (float i = 0.; i < 100.; i++) {\n"
    "        t += max(0.008, abs(d) * .8);\n"
    "        p = ro + rd * t;\n"
    "        d = map(p);\n"
    "        c = vec3(max(0., .01 - abs(d)) * .7);\n"
    "        c += vec3(0.271,0.094,0.306) * 0.0008;\n"
    "        c *= smoothstep(20., .4, length(t));\n"
    "        float l = smoothstep(MAX_DIST, .1, t);\n"
    "        c *= l;\n"
    "        c *= pal(l * 8. - .9);\n"
    "        col += c;\n"
    "        if (t > MAX_DIST) {\n"
    "            break;\n"
    "        }\n"
    "    }\n"
    "    col = pow(col, vec3(1. / 1.8)) * 2.;\n"
    "    col = pow(col, vec3(2.)) * 5.;\n"
    "    col *= tanh(col);\n"
    "    col = pow(col, vec3(1. / 2.2));\n"
    "    frag_color = vec4(col * u_color.rgb, 1.0).bgra;\n"
    "}\n";
    
    
// https://www.shadertoy.com/view/tlGfzd
static const char *desktop_14_fs_src = 
    "#version 300 es\n"
    "precision mediump float;\n"
    "in vec2 v_texcoord;\n"
    "out vec4 frag_color;\n"
    "uniform float time;\n"
    "uniform vec2 iResolution;\n"
    "uniform vec4 u_color;\n"
    "\n"
    "vec3 objcol;\n"
    "\n"
    "float hash12(vec2 p)\n"
    "{\n"
    "	vec3 p3  = fract(vec3(p.xyx) * .1031);\n"
    "    p3 += dot(p3, p3.yzx + 33.33);\n"
    "    return fract((p3.x + p3.y) * p3.z);\n"
    "}\n"
    "\n"
    "mat2 rot(float a){\n"
    "    float s = sin(a), c = cos(a);\n"
    "    return mat2(c, s, -s, c);\n"
    "}\n"
    "\n"
    "float de(vec3 pos)\n"
    "{\n"
    "    float t = mod(time,17.);\n"
    "    float a=smoothstep(13.,15.,t)*8.-smoothstep(4.,0.,t)*4.;\n"
    "    float f=sin(time*5.+sin(time*20.)*.2);\n"
    "    pos.xz *= rot(time+.5);\n"
    "    pos.yz *= rot(time);\n"
    "    vec3 p = pos;\n"
    "    float s=1.;\n"
    "    for (int i=0; i<4; i++){\n"
    "        p=abs(p)*1.3-.5-f*.1-a;\n"
    "        p.xy*=rot(radians(45.));\n"
    "        p.xz*=rot(radians(45.));\n"
    "        s*=1.3;\n"
    "    }\n"
    "    float fra = length(p)/s-.5;\n"
    "    pos.xy *= rot(time);\n"
    "    p = abs(pos) - 2. - a;\n"
    "    float d = length(p) - .7;\n"
    "    d = min(d, max(length(p.xz)-.1,p.y));\n"
    "    d = min(d, max(length(p.yz)-.1,p.x));\n"
    "    d = min(d, max(length(p.xy)-.1,p.z));\n"
    "    p = abs(pos);\n"
    "    p.x -= 4.+a+f*.5;\n"
    "    d = min(d, length(p) - .7);\n"
    "    d = min(d, length(p.yz-abs(sin(p.x*.5-time*10.)*.3)));\n"
    "    p = abs(pos);\n"
    "    p.y -= 4.+a+f*.5;\n"
    "    d = min(d, length(p) - .7);\n"
    "    d = min(d, max(length(p.xz)-.1,p.y));\n"
    "    d = min(d, fra);\n"
    "    objcol = abs(p);\n"
    "    if (d==fra) objcol=vec3(2.,0.,0.);\n"
    "    return d;\n"
    "}\n"
    "\n"
    "vec3 normal(vec3 p) {\n"
    "    vec2 d = vec2(0., .01);\n"
    "    return normalize(vec3(de(p+d.yxx), de(p+d.xyx), de(p+d.xxy))-de(p));\n"
    "}\n"
    "\n"
    "vec3 march(vec3 from, vec3 dir)\n"
    "{\n"
    "    float d = 0., td = 0., maxdist = 30.;\n"
    "    vec3 p = from, col = vec3(0.);\n"
    "    for (int i = 0; i<100; i++)\n"
    "    {\n"
    "        float d2 = de(p) * (1.-hash12(gl_FragCoord.xy+time)*.2);\n"
    "        if (d2<0.)\n"
    "        {\n"
    "            vec3 n = normal(p);\n"
    "            dir = reflect(dir, n);\n"
    "            d2 = .1;\n"
    "        }\n"
    "        d = max(.01, abs(d2));\n"
    "        p += d * dir;\n"
    "        td += d;\n"
    "        if (td>maxdist) break;\n"
    "        col += .01 * objcol;\n"
    "    }\n"
    "    return pow(col, vec3(2.));\n"
    "}\n"
    "\n"
    "void main()\n"
    "{\n"
    "    vec2 uv = gl_FragCoord.xy / iResolution.xy - .5;\n"
    "    uv.x *= iResolution.x / iResolution.y;\n"
    "    vec3 from = vec3(0.,0.,-10.);\n"
    "    vec3 dir = normalize(vec3(uv, 1.));\n"
    "    vec3 col = march(from, dir);\n"
    "    frag_color = vec4(col * u_color.rgb, 1.0).bgra;\n"
    "}\n";
    
// https://www.shadertoy.com/view/mts3RB
static const char *desktop_15_fs_src = 
    "#version 300 es\n"
    "precision mediump float;\n"
    "in vec2 v_texcoord;\n"
    "out vec4 frag_color;\n"
    "uniform float time;\n"
    "uniform vec2 iResolution;\n"
    "uniform vec4 u_color;\n"
    "\n"
    "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n"
    "#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n"
    "#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n"
    "#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n"
    "#define Tri(p,s,a) max(-dot(p,vec2(cos(-a),sin(-a))),max(dot(p,vec2(cos(a),sin(a))),max(abs(p).x-s.x,abs(p).y-s.y)))\n"
    "#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n"
    "#define SkewX(a) mat2(1.0,tan(a),0.0,1.0)\n"
    "#define SkewY(a) mat2(1.0,0.0,tan(a),1.0)\n"
    "\n"
    "float SimpleVesicaDistanceY(vec2 p, float r, float d) {\n"
    "    p.x = abs(p.x);\n"
    "    p.x+=d;\n"
    "    return length(p)-r;\n"
    "}\n"
    "\n"
    "float SimpleVesicaDistanceX(vec2 p, float r, float d) {\n"
    "    p.y = abs(p.y);\n"
    "    p.y+=d;\n"
    "    return length(p)-r;\n"
    "}\n"
    "\n"
    "float eyeBall(vec2 p){\n"
    "    vec2 prevP = p;\n"
    "    p.x += sin(time)*0.05;\n"
    "    float thickness = 0.002;\n"
    "    float d = abs(length(p)-0.1)-thickness;\n"
    "    float d2 = abs(length(p)-0.04)-thickness;\n"
    "    d = min(d,d2);\n"
    "    \n"
    "    p = DF(p,6.0);\n"
    "    p -= vec2(0.05);\n"
    "    p*=Rot(radians(45.));\n"
    "    d2 = B(p,vec2(0.001,0.015));\n"
    "    d = min(d,d2);\n"
    "    \n"
    "    p = prevP;\n"
    "    p.x += sin(time)*0.05;\n"
    "    d2 = length(p-vec2(-0.03,0.03))-0.015;\n"
    "    d = min(d,d2);\n"
    "    return d;\n"
    "}\n"
    "\n"
    "float eye(vec2 p){\n"
    "    p*=1.2;\n"
    "    vec2 prevP = p;\n"
    "    float thickness = 0.002;\n"
    "    float d = eyeBall(p);\n"
    "    float s = mod(time*0.5,2.3);\n"
    "    if(s<1.){\n"
    "        p.y*=1.+s;\n"
    "    } else if(s>=1. && s<2.){\n"
    "        p.y*=1.+2.-s;\n"
    "    }\n"
    "    float d2 = abs(SimpleVesicaDistanceX(p,0.21,0.1))-thickness;\n"
    "    float d3 = SimpleVesicaDistanceX(p,0.21,0.1);\n"
    "    d = max(d3,d);\n"
    "    \n"
    "    d = min(d,d2);\n"
    "    return d;\n"
    "}\n"
    "\n"
    "float arrow(vec2 p){\n"
    "    float d = Tri(p,vec2(0.22),radians(45.));\n"
    "    float d2 =Tri(p-vec2(0.0,-0.11),vec2(0.22),radians(45.));\n"
    "    d = max(-d2,d);\n"
    "    return d;\n"
    "}\n"
    "\n"
    "float featherBG(vec2 p){\n"
    "    p*=2.3;\n"
    "    vec2 prevP = p;\n"
    "    p.x*=mix(0.3,2.,smoothstep(-1.2,0.9,p.y));\n"
    "    float d = SimpleVesicaDistanceY(p,0.41,0.2);\n"
    "    return d;\n"
    "}\n"
    "\n"
    "float feather(vec2 p){\n"
    "    p*=2.3;\n"
    "    vec2 prevP = p;\n"
    "    p.x*=mix(0.3,2.,smoothstep(-1.2,0.9,p.y));\n"
    "    float d = abs(SimpleVesicaDistanceY(p,0.41,0.2))-0.003;\n"
    "    \n"
    "    p = prevP;\n"
    "    float d2 = B(p-vec2(0.,-0.035),vec2(0.003,0.38));\n"
    "    d = min(d,d2);\n"
    "    \n"
    "    p-=vec2(0.062,0.1);\n"
    "    p*=Rot(radians(-30.));\n"
    "    d2 = B(p,vec2(0.072,0.003));\n"
    "    d = min(d,d2);\n"
    "    \n"
    "    p = prevP;\n"
    "    p-=vec2(-0.048,0.18);\n"
    "    p*=Rot(radians(30.));\n"
    "    d2 = B(p,vec2(0.055,0.003));\n"
    "    d = min(d,d2);\n"
    "        \n"
    "    p = prevP;\n"
    "    p-=vec2(0.079,-0.03);\n"
    "    p*=Rot(radians(-30.));\n"
    "    d2 = B(p,vec2(0.089,0.003));\n"
    "    d = min(d,d2);\n"
    "    \n"
    "    p = prevP;\n"
    "    p-=vec2(-0.07,0.03);\n"
    "    p*=Rot(radians(30.));\n"
    "    d2 = B(p,vec2(0.083,0.003));\n"
    "    d = min(d,d2);\n"
    "    \n"
    "    p = prevP;\n"
    "    d2 = abs(length(p-vec2(-0.08,-0.06))-0.06)-0.003;\n"
    "    d = min(d,d2);\n"
    "    \n"
    "    p = prevP;\n"
    "    d2 = length(p-vec2(0.05,-0.11))-0.02;\n"
    "    d = min(d,d2);\n"
    "    d2 = length(p-vec2(0.11,-0.075))-0.02;\n"
    "    d = min(d,d2);\n"
    "    \n"
    "    d2 = B(p-vec2(0.07,0.032),vec2(0.003,0.068));\n"
    "    d = min(d,d2);\n"
    "    d2 = B(p-vec2(-0.06,0.105),vec2(0.003,0.081));\n"
    "    d = min(d,d2);\n"
    "    \n"
    "    d2 = abs(length(p-vec2(-0.035,0.25))-0.02)-0.003;\n"
    "    d = min(d,d2);\n"
    "    \n"
    "    d2 = abs(length(p-vec2(0.052,0.17))-0.03)-0.003;\n"
    "    d = min(d,d2);\n"
    "    \n"
    "    d2 = abs(length(p-vec2(0.035,0.24))-0.015)-0.003;\n"
    "    d = min(d,d2);\n"
    "    \n"
    "    p = prevP;\n"
    "    \n"
    "    p.x = abs(p.x);\n"
    "    \n"
    "    p-=vec2(0.08,-0.16);\n"
    "    p*=Rot(radians(-30.));\n"
    "    d2 = B(p,vec2(0.095,0.003));\n"
    "    d = min(d,d2);\n"
    "    p*=Rot(radians(30.));\n"
    "    p-=vec2(-0.03,-0.09);\n"
    "    d2 = B(p,vec2(0.003,0.075));\n"
    "    d = min(d,d2);\n"
    "    \n"
    "    p-=vec2(0.05,0.035);\n"
    "    d2 = B(p,vec2(0.003,0.066));\n"
    "    d = min(d,d2);\n"
    "    \n"
    "    return d;\n"
    "}\n"
    "\n"
    "float drawMainGraphic(vec2 p){\n"
    "    vec2 prevP = p;\n"
    "\n"
    "    float d = eye(p);\n"
    "\n"
    "    p*=Rot(radians(10.*time));\n"
    "    p = DF(p,3.0);\n"
    "    p -= vec2(0.235);\n"
    "    p*=Rot(radians(45.));\n"
    "    float d2 = feather(p);\n"
    "    d = min(d,d2);\n"
    "    \n"
    "    p = prevP;\n"
    "    p*=Rot(radians(10.*time));\n"
    "    p = DF(p,3.0);\n"
    "    p -= vec2(0.108);\n"
    "    d2 = abs(length(p)-0.02)-0.001;\n"
    "    d = min(d,d2);\n"
    "    \n"
    "    p = prevP;\n"
    "    d2 = abs(length(p)-0.155)-0.001;\n"
    "    d = min(d,d2);\n"
    "    \n"
    "    return d;\n"
    "}\n"
    "\n"
    "float isoCube(vec2 p){\n"
    "    vec2 prevP = p;\n"
    "    p.y*=1.5;\n"
    "    p*=Rot(radians(45.));\n"
    "    \n"
    "    float d = abs(B(p,vec2(0.1)))-0.002;\n"
    "    p = prevP;\n"
    "    p.x=abs(p.x);\n"
    "    p-=vec2(0.072,-0.12);\n"
    "    p.x*=1.41;\n"
    "    p.y*=1.41;\n"
    "    p*=SkewY(radians(-34.));\n"
    "    float d2 = abs(B(p,vec2(0.1)))-0.002;\n"
    "    d = min(d,d2);\n"
    "    return d;\n"
    "}\n"
    "\n"
    "float background(vec2 p){\n"
    "    p.y-=time*0.1;\n"
    "    p*=2.;\n"
    "    vec2 prevP = p;\n"
    "    p.x = mod(p.x,0.288)-0.144;\n"
    "    p.y = mod(p.y,0.48)-0.24;\n"
    "    float d = isoCube(p);\n"
    "    p = prevP;\n"
    "    p.x+=0.144;\n"
    "    p.x = mod(p.x,0.288)-0.144;\n"
    "    p.y+=0.24;\n"
    "    p.y = mod(p.y,0.48)-0.24;\n"
    "    float d2 = isoCube(p);\n"
    "    \n"
    "    return min(d,d2);\n"
    "}\n"
    "\n"
    "void main()\n"
    "{\n"
    "    vec2 p = (gl_FragCoord.xy-0.5*iResolution.xy)/iResolution.y;\n"
    "    vec2 prevP = p;\n"
    "    \n"
    "    vec3 col = vec3(0.);\n"
    "    float d = drawMainGraphic(p);\n"
    "    \n"
    "    float d6 = background(p);\n"
    "    d6 = max(-(length(p)-0.25),d6);\n"
    "    col = mix(col,vec3(0.5),S(d6,0.0));\n"
    "    \n"
    "    p = prevP;\n"
    "    p*=Rot(radians(7.*time));\n"
    "    p = DF(p,3.0);\n"
    "    p -= vec2(0.45);\n"
    "    p*=Rot(radians(45.));\n"
    "    float d5 =arrow(p);\n"
    "    col = mix(col,vec3(0.),S(d5,0.0));\n"
    "    col = mix(col,vec3(0.7),S(abs(d5)-0.001,0.0));\n"
    "    \n"
    "    // feather bg\n"
    "    p = prevP;\n"
    "    p*=Rot(radians(-5.*time));\n"
    "    p = DF(p,4.0);\n"
    "    p -= vec2(0.3);\n"
    "    p*=Rot(radians(45.));\n"
    "    float d4 = featherBG(p);\n"
    "    col = mix(col,vec3(0.),S(d4,0.0));\n"
    "    \n"
    "    p = prevP;\n"
    "    p*=Rot(radians(-5.*time));\n"
    "    p = DF(p,4.0);\n"
    "    p -= vec2(0.3);\n"
    "    p*=Rot(radians(45.));\n"
    "    float d3 = feather(p);\n"
    "    col = mix(col,vec3(0.8),S(d3,0.0));\n"
    "     \n"
    "    p = prevP;\n"
    "    \n"
    "    // feather bg\n"
    "    p*=Rot(radians(10.*time));\n"
    "    p = DF(p,3.0);\n"
    "    p -= vec2(0.235);\n"
    "    p*=Rot(radians(45.));\n"
    "    float d2 = featherBG(p);\n"
    "    col = mix(col,vec3(0.),S(d2,0.0));\n"
    "    col = mix(col,vec3(1.),S(d,0.0));\n"
    "    \n"
    "    frag_color = vec4(col * u_color.rgb, 1.0).bgra;\n"
    "}\n";

// Background Vertex Shader - Simple fullscreen quad

// Background Vertex Shader - Simple fullscreen quad
static const char *background_vertex_shader_src =
"#version 300 es\n"
"precision mediump float;\n"
// We define a simple quad in C, so we don't need complex inputs here
"const vec2 verts[4] = vec2[](vec2(-1,-1), vec2(1,-1), vec2(-1,1), vec2(1,1));\n"
"out vec2 v_uv;\n"
"void main() {\n"
"    vec2 pos = verts[gl_VertexID];\n"
"    gl_Position = vec4(pos, 0.0, 1.0);\n"
"    v_uv = pos * 0.5 + 0.5; // Convert from [-1,1] to [0,1] for UV coords\n"
"}\n";

// Background Fragment Shader - Multicolored flowing gradient

// Background Fragment Shader - Volumetric space/nebula shader
static const char *background_fragment_shader_src =
"#version 300 es\n"
"precision mediump float;\n"
"uniform float u_time; // Time for animation\n"
"in vec2 v_uv;\n"
"out vec4 FragColor;\n"
"\n"
"#define iterations 4\n"
"#define formuparam2 0.89\n"
"\n"
"#define volsteps 10\n"
"#define stepsize 0.190\n"
"\n"
"#define zoom 3.900\n"
"#define tile   0.450\n"
"#define speed2  0.010\n"
"\n"
"#define brightness 0.2\n"
"#define darkmatter 0.400\n"
"#define distfading 0.560\n"
"#define saturation 0.400\n"
"\n"
"#define transverseSpeed 1.1\n"
"#define cloud 0.2\n"
"\n"
"// Note: Using u_time instead of iTime, and v_uv for coordinates\n"
"// iResolution will be approximated with vec2(800.0, 600.0) or similar\n"
"\n"
"float triangle(float x, float a) {\n"
"    float output2 = 2.0 * abs(3.0 * ((x / a) - floor((x / a) + 0.5))) - 1.0;\n"
"    return output2;\n"
"}\n"
"\n"
"float field(in vec3 p) {\n"
"    float strength = 7.0 + 0.03 * log(1.e-6 + fract(sin(u_time) * 4373.11));\n"
"    float accum = 0.;\n"
"    float prev = 0.;\n"
"    float tw = 0.;\n"
"\n"
"    for (int i = 0; i < 6; ++i) {\n"
"        float mag = dot(p, p);\n"
"        p = abs(p) / mag + vec3(-.5, -.8 + 0.1 * sin(u_time * 0.2 + 2.0), -1.1 + 0.3 * cos(u_time * 0.15));\n"
"        float w = exp(-float(i) / 7.);\n"
"        accum += w * exp(-strength * pow(abs(mag - prev), 2.3));\n"
"        tw += w;\n"
"        prev = mag;\n"
"    }\n"
"    return max(0., 5. * accum / tw - .7);\n"
"}\n"
"\n"
"void main() {\n"
"    // Approximate iResolution - adjust these values based on your actual resolution\n"
"    vec2 iResolution = vec2(800.0, 600.0);\n"
"    float iTime = u_time/3.0;\n"
"    \n"
"    // Convert v_uv back to fragCoord style coordinates\n"
"    vec2 fragCoord = v_uv * iResolution;\n"
"    \n"
"    vec2 uv2 = 2. * fragCoord.xy / iResolution.xy - 1.;\n"
"    vec2 uvs = uv2 * iResolution.xy / max(iResolution.x, iResolution.y);\n"
"\n"
"    float time2 = iTime;\n"
"    \n"
"    float speed = speed2;\n"
"    speed = 0.005 * cos(time2*0.02 + 3.1415926/4.0);\n"
"    float formuparam = formuparam2;\n"
"    \n"
"    //get coords and direction\n"
"    vec2 uv = uvs;\n"
"    //mouse rotation\n"
"    float a_xz = 0.9;\n"
"    float a_yz = -.6;\n"
"    float a_xy = 0.9 + iTime*0.04;\n"
"\n"
"    mat2 rot_xz = mat2(cos(a_xz),sin(a_xz),-sin(a_xz),cos(a_xz));\n"
"    mat2 rot_yz = mat2(cos(a_yz),sin(a_yz),-sin(a_yz),cos(a_yz));\n"
"    mat2 rot_xy = mat2(cos(a_xy),sin(a_xy),-sin(a_xy),cos(a_xy));\n"
"\n"
"    float v2 =1.0;\n"
"\n"
"    vec3 dir=vec3(uv*zoom,1.);\n"
"    vec3 from=vec3(0.0, 0.0,0.0);\n"
"\n"
"    from.x -= 5.0* (0.5);\n"
"    from.y -= 5.0* (0.5);\n"
"\n"
"    vec3 forward = vec3(0.,0.,1.);\n"
"\n"
"    from.x += transverseSpeed*(1.0)*cos(0.01*iTime) + 0.001*iTime;\n"
"    from.y += transverseSpeed*(1.0)*sin(0.01*iTime) +0.001*iTime;\n"
"    from.z += 0.003*iTime;\n"
"\n"
"    dir.xy*=rot_xy;\n"
"    forward.xy *= rot_xy;\n"
"    dir.xz*=rot_xz;\n"
"    forward.xz *= rot_xz;\n"
"    dir.yz*= rot_yz;\n"
"    forward.yz *= rot_yz;\n"
"\n"
"    from.xy*=-rot_xy;\n"
"    from.xz*=rot_xz;\n"
"    from.yz*= rot_yz;\n"
"\n"
"    //zoom\n"
"    float zooom = (time2-3311.)*speed;\n"
"    from += forward* zooom;\n"
"    float sampleShift = mod( zooom, stepsize );\n"
"\n"
"    float zoffset = -sampleShift;\n"
"    sampleShift /= stepsize; // make from 0 to 1\n"
"\n"
"    //volumetric rendering\n"
"    float s=0.24;\n"
"    float s3 = s + stepsize/2.0;\n"
"    vec3 v=vec3(0.);\n"
"    float t3 = 0.0;\n"
"\n"
"    vec3 backCol2 = vec3(0.);\n"
"    for (int r=0; r<volsteps; r++) {\n"
"        vec3 p2=from+(s+zoffset)*dir;// + vec3(0.,0.,zoffset);\n"
"        vec3 p3=(from+(s3+zoffset)*dir )* (1.9/zoom);// + vec3(0.,0.,zoffset);\n"
"\n"
"        p2 = abs(vec3(tile)-mod(p2,vec3(tile*2.))); // tiling fold\n"
"        p3 = abs(vec3(tile)-mod(p3,vec3(tile*2.))); // tiling fold\n"
"\n"
"        #ifdef cloud\n"
"        t3 = field(p3);\n"
"        #endif\n"
"\n"
"        float pa,a=pa=0.;\n"
"        for (int i=0; i<iterations; i++) {\n"
"            p2=abs(p2)/dot(p2,p2)-formuparam; // the magic formula\n"
"            //p=abs(p)/max(dot(p,p),0.005)-formuparam; // another interesting way to reduce noise\n"
"            float D = abs(length(p2)-pa); // absolute sum of average change\n"
"\n"
"            if (i > 2)\n"
"            {\n"
"            a += i > 7 ? min( 12., D) : D;\n"
"            }\n"
"                pa=length(p2);\n"
"        }\n"
"\n"
"        //float dm=max(0.,darkmatter-a*a*.001); //dark matter\n"
"        a*=a*a; // add contrast\n"
"        //if (r>3) fade*=1.-dm; // dark matter, don't render near\n"
"        // brightens stuff up a bit\n"
"        float s1 = s+zoffset;\n"
"        // need closed form expression for this, now that we shift samples\n"
"        float fade = pow(distfading,max(0.,float(r)-sampleShift));\n"
"\n"
"        //t3 += fade;\n"
"        v+=fade;\n"
"        //backCol2 -= fade;\n"
"\n"
"        // fade out samples as they approach the camera\n"
"        if( r == 0 )\n"
"            fade *= (1. - (sampleShift));\n"
"        // fade in samples as they approach from the distance\n"
"        if( r == volsteps-1 )\n"
"            fade *= sampleShift;\n"
"        v+=vec3(s1,s1*s1,s1*s1*s1*s1)*a*brightness*fade; // coloring based on distance\n"
"\n"
"        backCol2 += mix(.4, 1., v2) * vec3(0.20 * t3 * t3 * t3, 0.4 * t3 * t3, t3 * 0.7) * fade;\n"
"\n"
"        s+=stepsize;\n"
"        s3 += stepsize;\n"
"    }\n"
"\n"
"    v=mix(vec3(length(v)),v,saturation);\n"
"    vec4 forCol2 = vec4(v*.01,1.);\n"
"\n"
"    #ifdef cloud\n"
"    backCol2 *= cloud;\n"
"    #endif\n"
"\n"
"    FragColor = forCol2 + vec4(backCol2*0.6, 1.0).bgra;\n"
"}\n";

//https://www.shadertoy.com/view/3ccSzN
//cubecap shader
static const char *desktop_cubecap_fs_src = 
    "#version 300 es\n"
    "precision mediump float;\n"
    "in vec2 v_texcoord;\n"
    "out vec4 frag_color;\n"
    "uniform float time;\n"
    "uniform vec2 iResolution;\n"
    "uniform vec4 u_color;\n"
    "\n"
    "#define iTime time\n"
    "\n"
    "void main() {\n"
    "    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n"
    "    \n"
    "    float frequency = 40.0;\n"
    "    float speed = 1.8;\n"
    "    float amplitude = 0.1;\n"
    "    \n"
    "    float dist = length(uv);\n"
    "    float height = sin(dist * frequency - iTime * speed) * amplitude;\n"
    "    \n"
    "    float delta = 0.001;\n"
    "    \n"
    "    // X gradient\n"
    "    float distX1 = length(uv + vec2(delta, 0.0));\n"
    "    float distX2 = length(uv - vec2(delta, 0.0));\n"
    "    float hX1 = sin(distX1 * frequency - iTime * speed) * amplitude;\n"
    "    float hX2 = sin(distX2 * frequency - iTime * speed) * amplitude;\n"
    "    float dx = (hX1 - hX2) / (2.0 * delta);\n"
    "    \n"
    "    // Y gradient\n"
    "    float distY1 = length(uv + vec2(0.0, delta));\n"
    "    float distY2 = length(uv - vec2(0.0, delta));\n"
    "    float hY1 = sin(distY1 * frequency - iTime * speed) * amplitude;\n"
    "    float hY2 = sin(distY2 * frequency - iTime * speed) * amplitude;\n"
    "    float dy = (hY1 - hY2) / (2.0 * delta);\n"
    "    \n"
    "    // Normal from gradient\n"
    "    vec3 normal = normalize(vec3(-dx, -dy, 1.0));\n"
    "    vec3 lightDir = normalize(vec3(0.3, sin(iTime * 0.2), 0.5));\n"
    "    \n"
    "    float brightness = clamp(exp(dot(normal, lightDir)) * 0.5, 0.0, 1.0);\n"
    "    \n"
    "    vec3 baseColor = vec3(1.0);\n"
    "    vec3 color = baseColor * brightness;\n"
    "    \n"
    "    frag_color = vec4(color * u_color.rgb, 1.0);\n"
    "}";

//tv effect
static const char *post_process_vert =
    "#version 300 es\n"
    "precision mediump float;\n"
    "\n"
    "// Input vertex position in [0, 1] range\n"
    "layout(location = 0) in vec2 a_position_01;\n"
    "// Input texture coordinate in [0, 1] range\n"
    "layout(location = 1) in vec2 a_texcoord;\n"
    "\n"
    "// Pass texture coordinate to the fragment shader\n"
    "out vec2 v_texcoord;\n"
    "\n"
    "void main() {\n"
    "    // Convert [0, 1] position to [-1, 1] Normalized Device Coordinates\n"
    "    gl_Position = vec4(a_position_01 * 2.0 - 1.0, 0.0, 1.0);\n"
    "\n"
    "    // Pass the texture coordinate through unchanged\n"
    "    v_texcoord = a_texcoord;\n"
    "}\n";


//tv effect
/*    
static const char *post_process_frag =
    "#version 300 es\n"
    "precision highp float;\n"
    "\n"
    "uniform sampler2D u_scene_texture;\n"
    "uniform float u_time;\n"
    "uniform vec2 iResolution;\n"
    "\n"
    "in vec2 v_texcoord;\n"
    "out vec4 FragColor;\n"
    "\n"
    "// --- HELPER FUNCTIONS (No change) ---\n"
    "float rand(vec2 co){ return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453); }\n"
    "float noise(vec2 pos) { vec2 i=floor(pos),f=fract(pos),u=f*f*(3.0-2.0*f); return mix(mix(rand(i),rand(i+vec2(1,0)),u.x),mix(rand(i+vec2(0,1)),rand(i+vec2(1,1)),u.x),u.y); }\n"
    "vec3 chromaticAberration(sampler2D tex,vec2 uv,float s){ vec2 o=(uv-0.5)*s; return vec3(texture(tex,uv+o).r,texture(tex,uv).g,texture(tex,uv-o).b); }\n"
    "float onOff(float a,float b,float c,float t){ return step(c,sin(t+a*cos(t*b))); }\n"
    "float ramp(float y,float s,float e){ float i=step(s,y)-step(e,y); return(1.-(y-s)/(e-s))*i; }\n"
    "float stripes(vec2 uv,float t){ float n=noise(uv*vec2(0.5,1)+vec2(1,3)); return ramp(mod(uv.y*4.+t/2.+sin(t+sin(t*0.63)),1.),0.5,0.6)*n; }\n"
    "vec2 screenDistort(vec2 uv){ uv-=0.5; uv=uv*1.2*(1./1.2+2.*uv.x*uv.x*uv.y*uv.y); uv+=0.5; return uv; }\n"
    "\n"
    "void main() {\n"
    "    // --- TIMING & PROGRESS (No change) ---\n"
    "    float cycle_duration = 5.0;\n"
    "    float half_cycle = cycle_duration / 2.0;\n"
    "    float time_in_cycle = mod(u_time, cycle_duration);\n"
    "    float progress;\n"
    "    bool turning_on = (time_in_cycle < half_cycle);\n"
    "    if (turning_on) { progress = time_in_cycle / half_cycle; } \n"
    "    else { progress = 1.0 - (time_in_cycle - half_cycle) / half_cycle; }\n"
    "    float eased_progress = pow(progress, 3.0);\n"
    "\n"
    "    float uniform_scale = eased_progress;\n"
    "    vec2 center = vec2(0.5, 0.5);\n"
    "    vec2 pos = v_texcoord - center;\n"
    "\n"
    "    // --- TV OFF STATE (No change) ---\n"
    "    if (abs(pos.x) > uniform_scale / 2.0 || abs(pos.y) > uniform_scale / 2.0) {\n"
    "        // ... (your existing off-state logic) ...\n"
    "        FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n"
    "        return;\n"
    "    }\n"
    "\n"
    "    // --- TV ON STATE --- \n"
    "    vec2 sample_coords = pos / uniform_scale + center;\n"
    "\n"
    "    // <<< START OF THE FIX: Calculate a single 'glitch_amount' >>>\n"
    "    // This variable will control ALL effects. It peaks in the middle of the animation\n"
    "    // and is 0.0 when the animation starts and ends.\n"
    "    float glitch_amount = progress * (1.0 - progress) * 7.0; // Parabolic curve, peaks at 1.0\n"
    "    glitch_amount = pow(glitch_amount, 2.0); // Sharpen the peak\n"
    "\n"
    "    // 1. Calculate the final, clean texture coordinate\n"
    "    vec2 clean_coords = sample_coords;\n"
    "    vec3 clean_color = texture(u_scene_texture, clean_coords).rgb;\n"
    "\n"
    "    // 2. Calculate the fully distorted texture coordinate\n"
    "    vec2 distorted_coords = screenDistort(sample_coords);\n"
    "    float h_dist = sin(distorted_coords.y * 800.0 + u_time * 8.0) * 0.01;\n"
    "    float v_dist = sin(distorted_coords.x * 600.0 + u_time * 6.0) * 0.005;\n"
    "    distorted_coords += vec2(h_dist, v_dist);\n"
    "    float vShift = 0.4 * onOff(2.0,3.0,0.9,u_time)*(sin(u_time)*sin(u_time*20.0) + (0.5 + 0.1*sin(u_time*200.0)*cos(u_time)));\n"
    "    distorted_coords.y = mod(distorted_coords.y + vShift, 1.0);\n"
    "    \n"
    "    // 3. Blend between clean and distorted coordinates based on glitch_amount\n"
    "    vec2 final_coords = mix(clean_coords, distorted_coords, glitch_amount);\n"
    "\n"
    "    // 4. Sample the texture and apply chromatic aberration\n"
    "    vec3 color = chromaticAberration(u_scene_texture, final_coords, glitch_amount * 0.015);\n"
    "\n"
    "    // 5. Calculate all additive glitch effects (noise, stripes)\n"
    "    float vigAmt = 3.0 + 0.3*sin(u_time + 5.0*cos(u_time*5.0));\n"
    "    float vignette = (1.0 - vigAmt*(v_texcoord.y-0.5)*(v_texcoord.y-0.5)) * (1.0-vigAmt*(v_texcoord.x-0.5)*(v_texcoord.x-0.5));\n"
    "    vec3 additive_glitches = vec3(0.0);\n"
    "    additive_glitches += stripes(v_texcoord, u_time);\n"
    "    additive_glitches += noise(v_texcoord * 2.0) * 0.5;\n"
    "    additive_glitches *= vignette;\n"
    "    additive_glitches *= (12.0 + mod(v_texcoord.y*30.0 + u_time, 1.0)) / 13.0;\n"
    "\n"
    "    // 6. Apply the glitches based on glitch_amount\n"
    "    color += additive_glitches * glitch_amount;\n"
    "\n"
    "    // 7. Apply the flash, which is independent of the main glitch amount\n"
    "    if (turning_on) {\n"
    "        float flash_intensity = smoothstep(0.35, 0.0, progress) * 0.6;\n"
    "        vec3 flash_color = vec3(1.8, 1.7, 1.6);\n"
    "        color = mix(color, flash_color, flash_intensity);\n"
    "    }\n"
    "\n"
    "    // 8. FINAL MIX: Blend the fully glitched color back to the clean color as the animation finishes.\n"
    "    // When eased_progress is 1.0, glitch_amount is 0.0, so this becomes 100% clean_color.\n"
    "    vec3 final_color = mix(color, clean_color, 1.0 - glitch_amount);\n"
    "\n"
    "    FragColor = vec4(clamp(final_color, 0.0, 1.0), 1.0);\n"
    "}\n";
*/

//swirl
/*
static const char *post_process_frag =
    "#version 300 es\n"
    "precision highp float;\n"
    "\n"
    "uniform sampler2D u_scene_texture;\n"
    "uniform float u_time;\n"
    "uniform vec2 iResolution;\n"
    "\n"
    "in vec2 v_texcoord;\n"
    "out vec4 FragColor;\n"
    "\n"
    "void main() {\n"
    "    // --- TIMING & PROGRESS ---\n"
    "    float cycle_duration = 5.0;\n"
    "    float half_cycle = cycle_duration / 2.0;\n"
    "    float time_in_cycle = mod(u_time, cycle_duration);\n"
    "    float progress;\n"
    "    bool flowing_in = (time_in_cycle < half_cycle);\n"
    "    if (flowing_in) { \n"
    "        progress = time_in_cycle / half_cycle; \n"
    "    } else { \n"
    "        progress = 1.0 - (time_in_cycle - half_cycle) / half_cycle; \n"
    "    }\n"
    "    \n"
    "    float smooth_progress = smoothstep(0.0, 1.0, progress);\n"
    "    \n"
    "    // --- LIQUID FLOW DISTORTION ---\n"
    "    vec2 uv = v_texcoord;\n"
    "    \n"
    "    // Create flowing liquid motion\n"
    "    float wave1 = sin(uv.x * 6.0 + u_time * 2.0) * 0.03;\n"
    "    float wave2 = sin(uv.y * 6.0 - u_time * 2.0) * 0.03;\n"
    "    float wave3 = sin((uv.x + uv.y) * 10.0 + u_time * 3.0) * 0.02;\n"
    "    \n"
    "    // Flowing displacement based on progress\n"
    "    vec2 flow_offset = vec2(wave1, wave2 ) * smooth_progress;\n"
    "    \n"
    "    // Radial distortion from center\n"
    "    vec2 center = vec2(0.5);\n"
    "    vec2 to_center = center - uv;\n"
    "    float dist_to_center = length(to_center);\n"
    "    \n"
    "    // Smooth radial flow\n"
    "    float radial_strength = smooth_progress * 0.01;\n"
    "    vec2 radial_flow = normalize(to_center) * sin(dist_to_center * 175.0 - u_time * 4.0) * radial_strength;\n"
    "    \n"
    "    // Combine distortions\n"
    "    vec2 distorted_uv = uv + flow_offset + radial_flow;\n"
    "    \n"
    "    // --- SAMPLING ---\n"
    "    vec3 original_color = texture(u_scene_texture, uv).rgb;\n"
    "    vec3 distorted_color = texture(u_scene_texture, distorted_uv).rgb;\n"
    "    \n"
    "    // --- FINAL BLEND ---\n"
    "    vec3 final_color = mix(distorted_color, distorted_color, smooth_progress);\n"
    "    \n"
    "    FragColor = vec4(final_color, 1.0);\n"
    "}\n";*/
//crt shift
/*
 static const char *post_process_frag =
    "#version 300 es\n"
    "precision mediump float;\n"
    "\n"
    "// The texture containing our fully rendered scene\n"
    "uniform sampler2D u_scene_texture;\n"
    "// A time uniform, useful for animated effects\n"
    "uniform float u_time;\n"
    "uniform vec2 iResolution;\n"
    "\n"
    "// The texture coordinate received from the vertex shader\n"
    "in vec2 v_texcoord;\n"
    "\n"
    "// The final output color for the pixel\n"
    "out vec4 FragColor;\n"
    "\n"
    "// Enhanced CRT effect parameters\n"
    "const float SCANLINE_INTENSITY = 0.6;\n"
    "const float CHROMATIC_ABERRATION = 0.018;\n"
    "const float BRIGHTNESS = 2.0;\n"
    "const float CONTRAST = 1.3;\n"
    "const float VIGNETTE_STRENGTH = 0.5;\n"
    "const float FLICKER_INTENSITY = 0.18;\n"
    "const float PHOSPHOR_GLOW = 0.3;\n"
    "const float SCREEN_CURVE = 0.0;\n"
    "\n"
    "// Apply screen curvature like old CRT monitors\n"
    "vec2 screenCurve(vec2 uv) {\n"
    "    uv = uv * 2.0 - 1.0;\n"
    "    vec2 offset = abs(uv.yx) * SCREEN_CURVE;\n"
    "    uv = uv + uv * offset * offset;\n"
    "    uv = uv * 0.5 + 0.5;\n"
    "    return uv;\n"
    "}\n"
    "\n"
    "// Generate enhanced scanlines with phosphor effect\n"
    "float scanline(vec2 uv) {\n"
    "    float line = sin(uv.y * 1000.0) * 0.5 + 0.5;\n"
    "    float scanlineEffect = pow(line, 2.0);\n"
    "    return 1.0 - SCANLINE_INTENSITY * (1.0 - scanlineEffect);\n"
    "}\n"
    "\n"
    "// RGB phosphor pattern simulation\n"
    "vec3 phosphorPattern(vec2 uv, vec3 color) {\n"
    "    vec2 pixel = uv * iResolution.xy;\n"
    "    \n"
    "    // Create RGB sub-pixel pattern\n"
    "    float subPixel = mod(pixel.x, 3.0);\n"
    "    vec3 phosphor = vec3(1.0);\n"
    "    \n"
    "    if (subPixel < 1.0) {\n"
    "        phosphor = vec3(1.2, 0.8, 0.8); // Red phosphor\n"
    "    } else if (subPixel < 2.0) {\n"
    "        phosphor = vec3(0.8, 1.2, 0.8); // Green phosphor\n"
    "    } else {\n"
    "        phosphor = vec3(0.8, 0.8, 1.2); // Blue phosphor\n"
    "    }\n"
    "    \n"
    "    return color * mix(vec3(1.0), phosphor, PHOSPHOR_GLOW);\n"
    "}\n"
    "\n"
    "// Apply vignette effect\n"
    "float vignette(vec2 uv) {\n"
    "    float dist = distance(uv, vec2(0.5));\n"
    "    return 1.0 - smoothstep(0.3, 0.8, dist) * VIGNETTE_STRENGTH;\n"
    "}\n"
    "\n"
    "// Enhanced flicker with multiple frequencies\n"
    "float flicker(float time) {\n"
    "    float flick1 = sin(time * 15.0) * 0.5 + 0.5;\n"
    "    float flick2 = sin(time * 30.0 + 3.14159) * 0.3 + 0.7;\n"
    "    float flick3 = sin(time * 60.0) * 0.1 + 0.9;\n"
    "    return 1.0 + FLICKER_INTENSITY * (flick1 * flick2 * flick3 - 0.5);\n"
    "}\n"
    "\n"
    "// Rolling interference lines\n"
    "float interference(vec2 uv, float time) {\n"
    "    float roll = sin((uv.y + time * 0.1) * 20.0) * 0.02;\n"
    "    float noise = sin((uv.y + time * 0.05) * 200.0) * 0.01;\n"
    "    return 1.0 + roll + noise;\n"
    "}\n"
    "\n"
    "void main() {\n"
    "    // --- TIMING SYSTEM ---\n"
    "    float cycle_duration = 5.0;\n"
    "    float time_in_cycle = mod(u_time, cycle_duration);\n"
    "    float effect_intensity = smoothstep(0.0, 1.0, time_in_cycle / cycle_duration);\n"
    "    effect_intensity = sin(effect_intensity * 3.14159); // Smooth rise and fall\n"
    "    \n"
    "    // Apply screen curvature\n"
    "    vec2 curved_uv = mix(v_texcoord, screenCurve(v_texcoord), effect_intensity);\n"
    "    \n"
    "    // Check if we're outside the curved screen bounds\n"
    "    if (curved_uv.x < 0.0 || curved_uv.x > 1.0 || curved_uv.y < 0.0 || curved_uv.y > 1.0) {\n"
    "        FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n"
    "        return;\n"
    "    }\n"
    "    \n"
    "    // Sample with enhanced chromatic aberration - now with wavy horizontal shift\n"
    "    float wave = sin(curved_uv.y * 10.0 + u_time * 10.0) * 0.5;\n"
    "    float aberration = CHROMATIC_ABERRATION * effect_intensity * (1.0 + wave);\n"
    "    vec2 offset = vec2(aberration, 0.0);\n"
    "    float r = texture(u_scene_texture, curved_uv + offset).r;\n"
    "    float g = texture(u_scene_texture, curved_uv).g;\n"
    "    float b = texture(u_scene_texture, curved_uv - offset).b;\n"
    "    \n"
    "    vec3 color = vec3(r, g, b);\n"
    "    \n"
    "    // Apply brightness and contrast\n"
    "    float brightness = mix(1.0, BRIGHTNESS, effect_intensity);\n"
    "    float contrast = mix(1.0, CONTRAST, effect_intensity);\n"
    "    color = color * brightness;\n"
    "    color = (color - 0.5) * contrast + 0.5;\n"
    "    \n"
    "    // Apply scanlines\n"
    "    float scanline_effect = mix(1.0, scanline(curved_uv), effect_intensity);\n"
    "    color *= scanline_effect;\n"
    "    \n"
    "    // Apply phosphor pattern\n"
    "    color = mix(color, phosphorPattern(curved_uv, color), effect_intensity);\n"
    "    \n"
    "    // Apply vignette\n"
    "    float vignette_effect = mix(1.0, vignette(curved_uv), effect_intensity);\n"
    "    color *= vignette_effect;\n"
    "    \n"
    "    // Apply flicker\n"
    "    float flicker_effect = mix(1.0, flicker(u_time), effect_intensity);\n"
    "    color *= flicker_effect;\n"
    "    \n"
    "    // Apply interference\n"
    "    float interference_effect = mix(1.0, interference(curved_uv, u_time), effect_intensity);\n"
    "    color *= interference_effect;\n"
    "    \n"
    "    // Add authentic CRT green tint\n"
    "    color.g *= mix(1.0, 1.08, effect_intensity);\n"
    "    \n"
    "    // Add slight warm glow\n"
    "    vec3 glow = vec3(0.02, 0.01, 0.0) * effect_intensity;\n"
    "    color += glow;\n"
    "    \n"
    "    // Clamp to prevent over-brightness\n"
    "    color = clamp(color, 0.0, 1.0);\n"
    "    \n"
    "    FragColor = vec4(color, 1.0);\n"
    "}\n";
*/
//crt golden
static const char *post_process_frag =
    "#version 300 es\n"
    "precision mediump float;\n"
    "\n"
    "// The texture containing our fully rendered scene\n"
    "uniform sampler2D u_scene_texture;\n"
    "// A time uniform, useful for animated effects\n"
    "uniform float u_time;\n"
    "uniform vec2 iResolution;\n"
    "\n"
    "// The texture coordinate received from the vertex shader\n"
    "in vec2 v_texcoord;\n"
    "\n"
    "// The final output color for the pixel\n"
    "out vec4 FragColor;\n"
    "\n"
    "// Enhanced CRT effect parameters\n"
    "const float SCANLINE_INTENSITY = 0.6;\n"
    "const float CHROMATIC_ABERRATION = 0.018;\n"
    "const float BRIGHTNESS = 2.0;\n"
    "const float CONTRAST = 1.3;\n"
    "const float VIGNETTE_STRENGTH = 0.5;\n"
    "const float FLICKER_INTENSITY = 0.18;\n"
    "const float PHOSPHOR_GLOW = 0.3;\n"
    "const float SCREEN_CURVE = 0.0;\n"
    "\n"
    "// Fractal noise functions from second shader\n"
    "vec3 effect(float speed, vec2 uv, float time, float scale) {\n"
    "    float t = mod(time * 0.005, 6.0);\n"
    "    float rt = 0.00000000000001 * sin(t * 0.45);\n"
    "    mat2 m1 = mat2(cos(rt), -sin(rt), -sin(rt), cos(rt));\n"
    "    vec2 uva = uv * m1 * scale;\n"
    "    float irt = 0.005 * cos(t * 0.05);\n"
    "    mat2 m2 = mat2(sin(irt), cos(irt), -cos(irt), sin(irt));\n"
    "    for (int i = 1; i < 100; i += 1) { // Reduced iterations for performance\n"
    "        float it = float(i);\n"
    "        uva *= m2;\n"
    "        uva.y += -1.0 + (0.6 / it) * cos(t + it * uva.x + 0.5 * it) * float(mod(it, 0.5) == 0.0);\n"
    "        uva.x += 1.0 + (0.5 / it) * cos(t + it * uva.y * 0.1 / 5.0 + 0.5 * (it + 15.0));\n"
    "    }\n"
    "    float r = 0.5 + 0.5 * sin(6.28318 * uva.x + t * 0.1);\n"
    "    float g = 0.5 + 0.5 * sin(6.28318 * uva.x + t * 0.2 + 2.0);\n"
    "    float b = 0.5 + 0.5 * sin(6.28318 * uva.x + t * 0.3 + 4.0);\n"
    "    return vec3(r, g, b);\n"
    "}\n"
    "\n"
    "float rand(in vec2 _st) {\n"
    "    return fract(sin(dot(_st.xy, vec2(-0.820, -0.840))) * 4757.153);\n"
    "}\n"
    "\n"
    "float noise(in vec2 _st) {\n"
    "    const vec2 d = vec2(0.0, 1.0);\n"
    "    vec2 b = floor(_st), f = smoothstep(vec2(0.0), vec2(0.1, 0.3), fract(_st));\n"
    "    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n"
    "}\n"
    "\n"
    "float fbm(in vec2 _st) {\n"
    "    float v = sin(u_time * 0.005) * 0.2;\n"
    "    float a = 0.3;\n"
    "    vec2 shift = vec2(100.0);\n"
    "    mat2 rot = mat2(cos(0.5), sin(1.0), -sin(0.5), cos(0.5));\n"
    "    for (int i = 0; i < 3; ++i) {\n"
    "        v += a * noise(_st);\n"
    "        _st = rot * _st * 2.0 + shift;\n"
    "        a *= 1.5;\n"
    "    }\n"
    "    return v;\n"
    "}\n"
    "\n"
    "vec4 fractal_effect(vec2 pos) {\n"
    "    vec2 st = (pos * 2.0 - iResolution) / min(iResolution.x, iResolution.y) * 0.5;\n"
    "    vec2 coord = st * 0.2;\n"
    "    float len;\n"
    "    for (int i = 0; i < 3; i++) {\n"
    "        len = length(coord);\n"
    "        coord.x += sin(coord.y + u_time * 0.001) * 2.1;\n"
    "        coord.y += cos(coord.x + u_time * 0.001 + cos(len * 1.0)) * 1.0;\n"
    "    }\n"
    "    len -= 3.0;\n"
    "    vec3 color = vec3(0.0);\n"
    "    vec2 q = vec2(0.0);\n"
    "    q.x = fbm(st);\n"
    "    q.y = fbm(st + vec2(-0.450, 0.650));\n"
    "    vec2 r = vec2(0.0);\n"
    "    r.x = fbm(st + 1.0 * q + vec2(0.570, 0.520) + 0.1 * u_time * 0.01);\n"
    "    r.y = fbm(st + 1.0 * q + vec2(0.340, -0.570) + 0.05 * u_time * 0.01);\n"
    "    float f = fbm(st + r);\n"
    "    color = effect(f, st, u_time, 1.0);\n"
    "    return vec4((f * f * f + .6 * f * f + .5 * f) * color, 1.0);\n"
    "}\n"
    "\n"
    "// Apply screen curvature like old CRT monitors\n"
    "vec2 screenCurve(vec2 uv) {\n"
    "    uv = uv * 2.0 - 1.0;\n"
    "    vec2 offset = abs(uv.yx) * SCREEN_CURVE;\n"
    "    uv = uv + uv * offset * offset;\n"
    "    uv = uv * 0.5 + 0.5;\n"
    "    return uv;\n"
    "}\n"
    "\n"
    "// CRT curve function from second shader\n"
    "vec2 curve(vec2 uv) {\n"
    "    uv = (uv - 0.5) * 2.0;\n"
    "    uv *= 1.1;\n"
    "    uv.x *= 1.0 + pow((abs(uv.y) / 8.0), 2.0);\n"
    "    uv.y *= 1.0 + pow((abs(uv.x) / 8.0), 2.0);\n"
    "    uv = (uv / 2.0) + 0.5;\n"
    "    uv = uv * 0.92 + 0.04;\n"
    "    return uv;\n"
    "}\n"
    "\n"
    "// Generate enhanced scanlines with phosphor effect\n"
    "float scanline(vec2 uv) {\n"
    "    float line = sin(uv.y * 1000.0) * 0.5 + 0.5;\n"
    "    float scanlineEffect = pow(line, 2.0);\n"
    "    return 1.0 - SCANLINE_INTENSITY * (1.0 - scanlineEffect);\n"
    "}\n"
    "\n"
    "// RGB phosphor pattern simulation\n"
    "vec3 phosphorPattern(vec2 uv, vec3 color) {\n"
    "    vec2 pixel = uv * iResolution.xy;\n"
    "    \n"
    "    // Create RGB sub-pixel pattern\n"
    "    float subPixel = mod(pixel.x, 3.0);\n"
    "    vec3 phosphor = vec3(1.0);\n"
    "    \n"
    "    if (subPixel < 1.0) {\n"
    "        phosphor = vec3(1.2, 0.8, 0.8); // Red phosphor\n"
    "    } else if (subPixel < 2.0) {\n"
    "        phosphor = vec3(0.8, 1.2, 0.8); // Green phosphor\n"
    "    } else {\n"
    "        phosphor = vec3(0.8, 0.8, 1.2); // Blue phosphor\n"
    "    }\n"
    "    \n"
    "    return color * mix(vec3(1.0), phosphor, PHOSPHOR_GLOW);\n"
    "}\n"
    "\n"
    "// Apply vignette effect\n"
    "float vignette(vec2 uv) {\n"
    "    float dist = distance(uv, vec2(0.5));\n"
    "    return 1.0 - smoothstep(0.3, 0.8, dist) * VIGNETTE_STRENGTH;\n"
    "}\n"
    "\n"
    "// Enhanced flicker with multiple frequencies\n"
    "float flicker(float time) {\n"
    "    float flick1 = sin(time * 15.0) * 0.5 + 0.5;\n"
    "    float flick2 = sin(time * 30.0 + 3.14159) * 0.3 + 0.7;\n"
    "    float flick3 = sin(time * 60.0) * 0.1 + 0.9;\n"
    "    return 1.0 + FLICKER_INTENSITY * (flick1 * flick2 * flick3 - 0.5);\n"
    "}\n"
    "\n"
    "// Rolling interference lines\n"
    "float interference(vec2 uv, float time) {\n"
    "    float roll = sin((uv.y + time * 0.1) * 20.0) * 0.02;\n"
    "    float noise = sin((uv.y + time * 0.05) * 200.0) * 0.01;\n"
    "    return 1.0 + roll + noise;\n"
    "}\n"
    "\n"
    "void main() {\n"
    "    // --- TIMING SYSTEM ---\n"
    "    float cycle_duration = 5.0;\n"
    "    float time_in_cycle = mod(u_time, cycle_duration);\n"
    "    float effect_intensity = smoothstep(0.0, 1.0, time_in_cycle / cycle_duration);\n"
    "    effect_intensity = sin(effect_intensity * 3.14159); // Smooth rise and fall\n"
    "    \n"
    "    // Apply screen curvature - blend between original and curved\n"
    "    vec2 curved_uv = mix(v_texcoord, curve(v_texcoord), effect_intensity);\n"
    "    \n"
    "    // Check if we're outside the curved screen bounds\n"
    "    if (curved_uv.x < 0.0 || curved_uv.x > 1.0 || curved_uv.y < 0.0 || curved_uv.y > 1.0) {\n"
    "        FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n"
    "        return;\n"
    "    }\n"
    "    \n"
    "    // Sample the original scene texture\n"
    "    vec3 scene_color = texture(u_scene_texture, curved_uv).rgb;\n"
    "    \n"
    "    // Generate fractal background effect\n"
    "    vec4 fractal_color = fractal_effect(curved_uv * iResolution);\n"
    "    \n"
    "    // Blend scene with fractal effect based on intensity\n"
    "    vec3 color = mix(scene_color, fractal_color.rgb * 0.5, effect_intensity * 0.3);\n"
    "    \n"
    "    // Sample with enhanced chromatic aberration - now with wavy horizontal shift\n"
    "    float wave = sin(curved_uv.y * 10.0 + u_time * 10.0) * 0.5;\n"
    "    float aberration = CHROMATIC_ABERRATION * effect_intensity * (1.0 + wave);\n"
    "    vec2 offset = vec2(aberration, 0.0);\n"
    "    float r = texture(u_scene_texture, curved_uv + offset).r;\n"
    "    float g = texture(u_scene_texture, curved_uv).g;\n"
    "    float b = texture(u_scene_texture, curved_uv - offset).b;\n"
    "    \n"
    "    // Blend chromatic aberration with fractal-enhanced color\n"
    "    vec3 aberrated_color = vec3(r, g, b);\n"
    "    color = mix(color, aberrated_color, 0.7);\n"
    "    \n"
    "    // Apply brightness and contrast\n"
    "    float brightness = mix(1.0, BRIGHTNESS, effect_intensity);\n"
    "    float contrast = mix(1.0, CONTRAST, effect_intensity);\n"
    "    color = color * brightness;\n"
    "    color = (color - 0.5) * contrast + 0.5;\n"
    "    \n"
    "    // Apply scanlines with enhanced effect from second shader\n"
    "    float scanvar = 0.5;\n"
    "    float scanlines = clamp(scanvar + scanvar * sin(60.0 * 1.95 * mod(-u_time, 8.0) + curved_uv.y * iResolution.y), 0.0, 1.0);\n"
    "    float s = pow(scanlines, 1.7);\n"
    "    color = color * mix(vec3(1.0), vec3(0.4 + 0.7 * s), effect_intensity);\n"
    "    \n"
    "    // Apply phosphor pattern\n"
    "    color = mix(color, phosphorPattern(curved_uv, color), effect_intensity);\n"
    "    \n"
    "    // Enhanced phosphor effect from second shader\n"
    "    float phosphor = 0.10 * effect_intensity;\n"
    "    float rPhosphor = clamp(phosphor + phosphor * sin((curved_uv.x) * iResolution.x * 1.333333333), 0.0, 1.0);\n"
    "    float gPhosphor = clamp(phosphor + phosphor * sin((curved_uv.x + 0.333333333) * iResolution.x * 1.333333333), 0.0, 1.0);\n"
    "    float bPhosphor = clamp(phosphor + phosphor * sin((curved_uv.x + 0.666666666) * iResolution.x * 1.333333333), 0.0, 1.0);\n"
    "    color.r -= rPhosphor;\n"
    "    color.g -= gPhosphor;\n"
    "    color.b -= bPhosphor;\n"
    "    \n"
    "    // Apply vignette\n"
    "    float vignette_effect = mix(1.0, vignette(curved_uv), effect_intensity);\n"
    "    color *= vignette_effect;\n"
    "    \n"
    "    // Enhanced vignette from second shader\n"
    "    float vignetteStrenght = 0.01 * effect_intensity;\n"
    "    float vignetteExtend = 0.5;\n"
    "    vec2 uv_ = curved_uv * (1.0 - curved_uv.yx);\n"
    "    float vignette2 = uv_.x * uv_.y * vignetteStrenght;\n"
    "    vignette2 = clamp(pow(vignette2, vignetteExtend), 0., 1.0);\n"
    "    color *= mix(vec3(1.0), vec3(0.9 + 0.1 * vignette2), 1.0);\n"
    "    \n"
    "    // Apply flicker with enhanced effect\n"
    "    float flicker_effect = mix(1.0, flicker(u_time), effect_intensity);\n"
    "    float flickerAmount = 0.1 * effect_intensity;\n"
    "    flicker_effect *= 1.0 + flickerAmount * sin(60.0 * 2.0 * u_time);\n"
    "    color *= flicker_effect;\n"
    "    \n"
    "    // Apply interference\n"
    "    float interference_effect = mix(1.0, interference(curved_uv, u_time), effect_intensity);\n"
    "    color *= interference_effect;\n"
    "    \n"
    "    // Analog noise from second shader\n"
    "    float analog_noise = fract(sin(u_time) * 43758.5453123 * curved_uv.y) * 0.0006 * effect_intensity;\n"
    "    color += analog_noise;\n"
    "    \n"
    "    // Add authentic CRT green tint\n"
    "    color.g *= mix(1.0, 1.08, effect_intensity);\n"
    "    \n"
    "    // Add slight warm glow\n"
    "    vec3 glow = vec3(0.02, 0.01, 0.0) * effect_intensity;\n"
    "    color += glow;\n"
    "    \n"
    "    // Color mixing from second shader\n"
    "    color.r = mix(color.r, mix(color.g, color.b, 0.9), 0.05 * effect_intensity);\n"
    "    color.g = mix(color.g, mix(color.r, color.b, 0.3), 0.05 * effect_intensity);\n"
    "    color.b = mix(color.b, mix(color.g, color.r, 0.8), 0.05 * effect_intensity);\n"
    "    color.rb *= mix(vec2(1.0), vec2(1.04, 0.8), effect_intensity);\n"
    "    \n"
    "    // Clamp to prevent over-brightness\n"
    "    color = clamp(color, 0.0, 1.0);\n"
    "    \n"
    "    FragColor = vec4(color, 1.0);\n"
    "}";

/*
static const char *post_process_frag =
    "#version 300 es\n"
    "precision mediump float;\n"
    "\n"
    "// The texture containing our fully rendered scene\n"
    "uniform sampler2D u_scene_texture;\n"
    "// A time uniform, useful for animated effects\n"
    "uniform float u_time;\n"
    "uniform vec2 iResolution;\n"
    "\n"
    "// The texture coordinate received from the vertex shader\n"
    "in vec2 v_texcoord;\n"
    "\n"
    "// The final output color for the pixel\n"
    "out vec4 FragColor;\n"
    "\n"
    "// Enhanced CRT effect parameters\n"
    "const float SCANLINE_INTENSITY = 0.6;\n"
    "const float CHROMATIC_ABERRATION = 0.018;\n"
    "const float BRIGHTNESS = 2.0;\n"
    "const float CONTRAST = 1.3;\n"
    "const float VIGNETTE_STRENGTH = 0.5;\n"
    "const float FLICKER_INTENSITY = 0.18;\n"
    "const float PHOSPHOR_GLOW = 0.3;\n"
    "const float SCREEN_CURVE = 0.0;\n"
    "\n"
    "// Fractal noise functions from second shader\n"
    "vec3 effect(float speed, vec2 uv, float time, float scale) {\n"
    "    float t = mod(time * 0.005, 6.0);\n"
    "    float rt = 0.00000000000001 * sin(t * 0.45);\n"
    "    mat2 m1 = mat2(cos(rt), -sin(rt), -sin(rt), cos(rt));\n"
    "    vec2 uva = uv * m1 * scale;\n"
    "    float irt = 0.005 * cos(t * 0.05);\n"
    "    mat2 m2 = mat2(sin(irt), cos(irt), -cos(irt), sin(irt));\n"
    "    for (int i = 1; i < 100; i += 1) { // Reduced iterations for performance\n"
    "        float it = float(i);\n"
    "        uva *= m2;\n"
    "        uva.y += -1.0 + (0.6 / it) * cos(t + it * uva.x + 0.5 * it) * float(mod(it, 0.5) == 0.0);\n"
    "        uva.x += 1.0 + (0.5 / it) * cos(t + it * uva.y * 0.1 / 5.0 + 0.5 * (it + 15.0));\n"
    "    }\n"
    "    float r = 0.5 + 0.5 * sin(6.28318 * uva.x + t * 0.1);\n"
    "    float g = 0.5 + 0.5 * sin(6.28318 * uva.x + t * 0.2 + 2.0);\n"
    "    float b = 0.5 + 0.5 * sin(6.28318 * uva.x + t * 0.3 + 4.0);\n"
    "    return vec3(r, g, b);\n"
    "}\n"
    "\n"
    "float rand(in vec2 _st) {\n"
    "    return fract(sin(dot(_st.xy, vec2(-0.820, -0.840))) * 4757.153);\n"
    "}\n"
    "\n"
    "float noise(in vec2 _st) {\n"
    "    const vec2 d = vec2(0.0, 1.0);\n"
    "    vec2 b = floor(_st), f = smoothstep(vec2(0.0), vec2(0.1, 0.3), fract(_st));\n"
    "    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n"
    "}\n"
    "\n"
    "float fbm(in vec2 _st) {\n"
    "    float v = sin(u_time * 0.005) * 0.2;\n"
    "    float a = 0.3;\n"
    "    vec2 shift = vec2(100.0);\n"
    "    mat2 rot = mat2(cos(0.5), sin(1.0), -sin(0.5), cos(0.5));\n"
    "    for (int i = 0; i < 3; ++i) {\n"
    "        v += a * noise(_st);\n"
    "        _st = rot * _st * 2.0 + shift;\n"
    "        a *= 1.5;\n"
    "    }\n"
    "    return v;\n"
    "}\n"
    "\n"
    "vec4 fractal_effect(vec2 pos) {\n"
    "    vec2 st = (pos * 2.0 - iResolution) / min(iResolution.x, iResolution.y) * 0.5;\n"
    "    vec2 coord = st * 0.2;\n"
    "    float len;\n"
    "    for (int i = 0; i < 3; i++) {\n"
    "        len = length(coord);\n"
    "        coord.x += sin(coord.y + u_time * 0.001) * 2.1;\n"
    "        coord.y += cos(coord.x + u_time * 0.001 + cos(len * 1.0)) * 1.0;\n"
    "    }\n"
    "    len -= 3.0;\n"
    "    vec3 color = vec3(0.0);\n"
    "    vec2 q = vec2(0.0);\n"
    "    q.x = fbm(st);\n"
    "    q.y = fbm(st + vec2(-0.450, 0.650));\n"
    "    vec2 r = vec2(0.0);\n"
    "    r.x = fbm(st + 1.0 * q + vec2(0.570, 0.520) + 0.1 * u_time * 0.01);\n"
    "    r.y = fbm(st + 1.0 * q + vec2(0.340, -0.570) + 0.05 * u_time * 0.01);\n"
    "    float f = fbm(st + r);\n"
    "    color = effect(f, st, u_time, 1.0);\n"
    "    return vec4((f * f * f + .6 * f * f + .5 * f) * color, 1.0);\n"
    "}\n"
    "\n"
    "// Apply screen curvature like old CRT monitors\n"
    "vec2 screenCurve(vec2 uv) {\n"
    "    uv = uv * 2.0 - 1.0;\n"
    "    vec2 offset = abs(uv.yx) * SCREEN_CURVE;\n"
    "    uv = uv + uv * offset * offset;\n"
    "    uv = uv * 0.5 + 0.5;\n"
    "    return uv;\n"
    "}\n"
    "\n"
    "// CRT curve function from second shader\n"
    "vec2 curve(vec2 uv) {\n"
    "    uv = (uv - 0.5) * 2.0;\n"
    "    uv *= 1.1;\n"
    "    uv.x *= 1.0 + pow((abs(uv.y) / 8.0), 2.0);\n"
    "    uv.y *= 1.0 + pow((abs(uv.x) / 8.0), 2.0);\n"
    "    uv = (uv / 2.0) + 0.5;\n"
    "    uv = uv * 0.92 + 0.04;\n"
    "    return uv;\n"
    "}\n"
    "\n"
    "// Generate enhanced scanlines with phosphor effect\n"
    "float scanline(vec2 uv) {\n"
    "    float line = sin(uv.y * 1000.0) * 0.5 + 0.5;\n"
    "    float scanlineEffect = pow(line, 2.0);\n"
    "    return 1.0 - SCANLINE_INTENSITY * (1.0 - scanlineEffect);\n"
    "}\n"
    "\n"
    "// RGB phosphor pattern simulation\n"
    "vec3 phosphorPattern(vec2 uv, vec3 color) {\n"
    "    vec2 pixel = uv * iResolution.xy;\n"
    "    \n"
    "    // Create RGB sub-pixel pattern\n"
    "    float subPixel = mod(pixel.x, 3.0);\n"
    "    vec3 phosphor = vec3(1.0);\n"
    "    \n"
    "    if (subPixel < 1.0) {\n"
    "        phosphor = vec3(1.2, 0.8, 0.8); // Red phosphor\n"
    "    } else if (subPixel < 2.0) {\n"
    "        phosphor = vec3(0.8, 1.2, 0.8); // Green phosphor\n"
    "    } else {\n"
    "        phosphor = vec3(0.8, 0.8, 1.2); // Blue phosphor\n"
    "    }\n"
    "    \n"
    "    return color * mix(vec3(1.0), phosphor, PHOSPHOR_GLOW);\n"
    "}\n"
    "\n"
    "// Apply vignette effect\n"
    "float vignette(vec2 uv) {\n"
    "    float dist = distance(uv, vec2(0.5));\n"
    "    return 1.0 - smoothstep(0.3, 0.8, dist) * VIGNETTE_STRENGTH;\n"
    "}\n"
    "\n"
    "// Enhanced flicker with multiple frequencies\n"
    "float flicker(float time) {\n"
    "    float flick1 = sin(time * 15.0) * 0.5 + 0.5;\n"
    "    float flick2 = sin(time * 30.0 + 3.14159) * 0.3 + 0.7;\n"
    "    float flick3 = sin(time * 60.0) * 0.1 + 0.9;\n"
    "    return 1.0 + FLICKER_INTENSITY * (flick1 * flick2 * flick3 - 0.5);\n"
    "}\n"
    "\n"
    "// Rolling interference lines\n"
    "float interference(vec2 uv, float time) {\n"
    "    float roll = sin((uv.y + time * 0.1) * 20.0) * 0.02;\n"
    "    float noise = sin((uv.y + time * 0.05) * 200.0) * 0.01;\n"
    "    return 1.0 + roll + noise;\n"
    "}\n"
    "\n"
    "void main() {\n"
    "    // --- TIMING SYSTEM ---\n"
    "    float cycle_duration = 5.0;\n"
    "    float time_in_cycle = mod(u_time, cycle_duration);\n"
    "    float effect_intensity = smoothstep(0.0, 1.0, time_in_cycle / cycle_duration);\n"
    "    effect_intensity = sin(effect_intensity * 3.14159); // Smooth rise and fall\n"
    "    \n"
    "    // Apply screen curvature - blend between original and curved\n"
    "    vec2 curved_uv = mix(v_texcoord, curve(v_texcoord), effect_intensity);\n"
    "    \n"
    "    // Check if we're outside the curved screen bounds\n"
    "    if (curved_uv.x < 0.0 || curved_uv.x > 1.0 || curved_uv.y < 0.0 || curved_uv.y > 1.0) {\n"
    "        FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n"
    "        return;\n"
    "    }\n"
    "    \n"
    "    // Sample the original scene texture\n"
    "    vec3 scene_color = texture(u_scene_texture, curved_uv).rgb;\n"
    "    \n"
    "    // Generate fractal background effect\n"
    "    vec4 fractal_color = fractal_effect(curved_uv * iResolution);\n"
    "    \n"
    "    // Blend scene with fractal effect based on intensity\n"
    "    vec3 color = mix(scene_color, fractal_color.rgb * 0.5, effect_intensity * 0.3);\n"
    "    \n"
    "    // Sample with enhanced chromatic aberration - now with wavy horizontal shift\n"
    "    float wave = sin(curved_uv.y * 10.0 + u_time * 10.0) * 0.5;\n"
    "    float aberration = CHROMATIC_ABERRATION * effect_intensity * (1.0 + wave);\n"
    "    vec2 offset = vec2(aberration, 0.0);\n"
    "    float r = texture(u_scene_texture, curved_uv + offset).r;\n"
    "    float g = texture(u_scene_texture, curved_uv).g;\n"
    "    float b = texture(u_scene_texture, curved_uv - offset).b;\n"
    "    \n"
    "    // Blend chromatic aberration with fractal-enhanced color\n"
    "    vec3 aberrated_color = vec3(r, g, b);\n"
    "    color = mix(color, aberrated_color, 0.7);\n"
    "    \n"
    "    // Apply brightness and contrast\n"
    "    float brightness = mix(1.0, BRIGHTNESS, effect_intensity);\n"
    "    float contrast = mix(1.0, CONTRAST, effect_intensity);\n"
    "    color = color * brightness;\n"
    "    color = (color - 0.5) * contrast + 0.5;\n"
    "    \n"
    "    // Apply scanlines with enhanced effect from second shader\n"
    "    float scanvar = 0.5;\n"
    "    float scanlines = clamp(scanvar + scanvar * sin(60.0 * 1.95 * mod(-u_time, 8.0) + curved_uv.y * iResolution.y), 0.0, 1.0);\n"
    "    float s = pow(scanlines, 1.7);\n"
    "    color = color * mix(vec3(1.0), vec3(0.4 + 0.7 * s), effect_intensity);\n"
    "    \n"
    "    // Apply phosphor pattern\n"
    "    color = mix(color, phosphorPattern(curved_uv, color), effect_intensity);\n"
    "    \n"
    "    // Enhanced phosphor effect from second shader\n"
    "    float phosphor = 0.10 * effect_intensity;\n"
    "    float rPhosphor = clamp(phosphor + phosphor * sin((curved_uv.x) * iResolution.x * 1.333333333), 0.0, 1.0);\n"
    "    float gPhosphor = clamp(phosphor + phosphor * sin((curved_uv.x + 0.333333333) * iResolution.x * 1.333333333), 0.0, 1.0);\n"
    "    float bPhosphor = clamp(phosphor + phosphor * sin((curved_uv.x + 0.666666666) * iResolution.x * 1.333333333), 0.0, 1.0);\n"
    "    color.r -= rPhosphor;\n"
    "    color.g -= gPhosphor;\n"
    "    color.b -= bPhosphor;\n"
    "    \n"
    "    // Apply vignette\n"
    "    float vignette_effect = mix(1.0, vignette(curved_uv), effect_intensity);\n"
    "    color *= vignette_effect;\n"
    "    \n"
    "    // Enhanced vignette from second shader\n"
    "    float vignetteStrenght = 0.01 * effect_intensity;\n"
    "    float vignetteExtend = 0.5;\n"
    "    vec2 uv_ = curved_uv * (1.0 - curved_uv.yx);\n"
    "    float vignette2 = uv_.x * uv_.y * vignetteStrenght;\n"
    "    vignette2 = clamp(pow(vignette2, vignetteExtend), 0., 1.0);\n"
    "    color *= mix(vec3(1.0), vec3(vignette2), effect_intensity);\n"
    "    \n"
    "    // Apply flicker with enhanced effect\n"
    "    float flicker_effect = mix(1.0, flicker(u_time), effect_intensity);\n"
    "    float flickerAmount = 0.1 * effect_intensity;\n"
    "    flicker_effect *= 1.0 + flickerAmount * sin(60.0 * 2.0 * u_time);\n"
    "    color *= flicker_effect;\n"
    "    \n"
    "    // Apply interference\n"
    "    float interference_effect = mix(1.0, interference(curved_uv, u_time), effect_intensity);\n"
    "    color *= interference_effect;\n"
    "    \n"
    "    // Analog noise from second shader\n"
    "    float analog_noise = fract(sin(u_time) * 43758.5453123 * curved_uv.y) * 0.0006 * effect_intensity;\n"
    "    color += analog_noise;\n"
    "    \n"
    "    // Add authentic CRT green tint\n"
    "    color.g *= mix(1.0, 1.08, effect_intensity);\n"
    "    \n"
    "    // Add slight warm glow\n"
    "    vec3 glow = vec3(0.02, 0.01, 0.0) * effect_intensity;\n"
    "    color += glow;\n"
    "    \n"
    "    // Color mixing from second shader\n"
    "    color.r = mix(color.r, mix(color.g, color.b, 0.9), 0.05 * effect_intensity);\n"
    "    color.g = mix(color.g, mix(color.r, color.b, 0.3), 0.05 * effect_intensity);\n"
    "    color.b = mix(color.b, mix(color.g, color.r, 0.8), 0.05 * effect_intensity);\n"
    "    color.rb *= mix(vec2(1.0), vec2(1.04, 0.8), effect_intensity);\n"
    "    \n"
    "    // Clamp to prevent over-brightness\n"
    "    color = clamp(color, 0.0, 1.0);\n"
    "    \n"
    "    FragColor = vec4(color, 1.0);\n"
    "}";*/
/*
// NEW: A simple vertex shader, can be the same as your others.
static const char *passthrough_vertex_shader_src =
    "#version 300 es\n"
    "precision mediump float;\n"
    "layout(location = 0) in vec2 position;\n"
    "layout(location = 1) in vec2 texcoord;\n"
    "out vec2 v_texcoord;\n"
    "uniform mat3 mvp;\n"
    "void main() {\n"
    "    vec3 pos_transformed = mvp * vec3(position, 1.0);\n"
    "    gl_Position = vec4(pos_transformed.xy, 0.0, 1.0);\n"
    "    v_texcoord = texcoord;\n"
    "}\n";

// NEW: A simple fragment shader that just renders a texture as-is.
static const char *passthrough_fragment_shader_src =
    "#version 300 es\n"
    "precision mediump float;\n"
    "in vec2 v_texcoord;\n"
    "out vec4 frag_color;\n"
    "uniform sampler2D u_texture;\n"
    "void main() {\n"
    "    // Just sample the texture and output its color, swizzling to BGRA.\n"
    "    frag_color = texture(u_texture, v_texcoord).bgra;\n"
    "}\n";
*/

// The vertex shader can remain the same.
static const char *passthrough_vertex_shader_src =
    "#version 300 es\n"
    "precision mediump float;\n"
    "layout(location = 0) in vec2 position;\n"
    "layout(location = 1) in vec2 texcoord;\n"
    "out vec2 v_texcoord;\n"
    "uniform mat3 mvp;\n"
    "void main() {\n"
    "    vec3 pos_transformed = mvp * vec3(position, 1.0);\n"
    "    gl_Position = vec4(pos_transformed.xy, 0.0, 1.0);\n"
    "    v_texcoord = texcoord;\n"
    "}\n";

// NEW: Enhanced fragment shader with rounded corners and a bevel.

static const char *passthrough_fragment_shader_src =
    "#version 300 es\n"
    "precision highp float;\n"
    "in vec2 v_texcoord;\n"
    "out vec4 frag_color;\n"
    "\n"
    "uniform sampler2D u_texture;\n"
    "uniform vec2 iResolution;\n"
    "uniform float cornerRadius;\n"
    "uniform vec4 bevelColor;       // The BASE color, controlled by C code.\n"
    "uniform float time;           // <<< THIS WAS MISSING! It's needed for the gradient.\n"
    "\n"
    "const float bevelWidth = 4.0;\n"
    "const float aa = 1.5;\n"
    "\n"
    "// SDF function (unchanged)\n"
    "float sdRoundedBox(vec2 p, vec2 b, float r) {\n"
    "    vec2 q = abs(p) - b + r;\n"
    "    return min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r;\n"
    "}\n"
    "\n"
    "void main() {\n"
    "    // --- 1. Shape Calculation (unchanged) ---\n"
    "    vec2 p = (v_texcoord - 0.5) * iResolution;\n"
    "    float d = sdRoundedBox(p, iResolution * 0.5, cornerRadius);\n"
    "\n"
    "    // --- 2. Alpha Mask (unchanged) ---\n"
    "    float shape_alpha = 1.0 - smoothstep(-aa, aa, d);\n"
    "\n"
    "    // --- 3. Bevel Intensity (unchanged) ---\n"
    "    float bevel_intensity = smoothstep(-bevelWidth, 0.0, d);\n"
    "    bevel_intensity -= smoothstep(0.0, aa, d);\n"
    "\n"
    "    // --- 4. Moving Gradient Calculation ---\n"
    "    float angle = atan(p.y, p.x);\n"
    "    float gradient_wave = sin(angle * 2.0 - time * 2.5) * 0.5 + 0.5;\n"
    "    float highlight_factor = pow(gradient_wave, 8.0);\n"
    "    float brightness_modulator = 0.7 + highlight_factor * 0.6;\n"
    "\n"
    "    // --- 5. Color Composition ---\n"
    "    vec4 tex_color = texture(u_texture, v_texcoord);\n"
    "\n"
    "    // Modulate the base bevel color from C with our moving brightness gradient.\n"
    "    vec3 final_bevel_color = bevelColor.rgb * brightness_modulator;\n"
    "\n"
    "    // Mix the texture color with the final, highlighted bevel color.\n"
    "    vec3 final_rgb = mix(tex_color.rgb, final_bevel_color, bevel_intensity * bevelColor.a);\n"
    "\n"
    "    // --- 6. Final Output ---\n"
    "    float final_alpha = tex_color.a * shape_alpha;\n"
    "    frag_color = vec4(final_rgb, final_alpha).bgra;\n"
    "}\n";

static const char *passthrough_icons_fragment_shader_src =
    "#version 300 es\n"
    "precision highp float;\n"
    "in vec2 v_texcoord;\n"
    "out vec4 frag_color;\n"
    "\n"
    "uniform sampler2D u_texture;\n"
    "uniform vec2 iResolution;\n"
    "uniform float cornerRadius;\n"
    "uniform vec4 bevelColor;\n"
    "uniform float time;\n"
    "\n"
    "const float bevelWidth = 12.0; // Increased for visibility\n"
    "const float aa = 1.5;\n"
    "const float blurRadius = 2.0;\n"
    "const int blurSamples = 9;\n"
    "\n"
    "float sdRoundedBox(vec2 p, vec2 b, float r) {\n"
    "    vec2 q = abs(p) - b + r;\n"
    "    return min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r;\n"
    "}\n"
    "\n"
    "vec4 gaussianBlur(sampler2D tex, vec2 uv, vec2 texelSize, float radius) {\n"
    "    vec4 color = vec4(0.0);\n"
    "    float total = 0.0;\n"
    "    \n"
    "    // 3x3 Gaussian kernel weights\n"
    "    float weights[9] = float[9](\n"
    "        1.0, 2.0, 1.0,\n"
    "        2.0, 4.0, 2.0,\n"
    "        1.0, 2.0, 1.0\n"
    "    );\n"
    "    \n"
    "    int index = 0;\n"
    "    for (int x = -1; x <= 1; x++) {\n"
    "        for (int y = -1; y <= 1; y++) {\n"
    "            vec2 offset = vec2(float(x), float(y)) * texelSize * radius;\n"
    "            vec2 sampleUV = clamp(uv + offset, 0.0, 1.0);\n"
    "            color += texture(tex, sampleUV) * weights[index];\n"
    "            total += weights[index];\n"
    "            index++;\n"
    "        }\n"
    "    }\n"
    "    \n"
    "    return color / total;\n"
    "}\n"
    "\n"
    "void main() {\n"
    "    float bounce = sin(time * 3.0) * 0.03 + 1.00;\n"
    "    vec2 p = (v_texcoord - 0.5) * iResolution;\n"
    "    float scaledCornerRadius = cornerRadius * bounce;\n"
    "    float d = sdRoundedBox(p, iResolution * 0.5 * bounce, scaledCornerRadius);\n"
    "    float shape_alpha = 1.0 - smoothstep(-aa, aa, d);\n"
    "    float bevel_intensity = smoothstep(-bevelWidth, 0.0, d);\n"
    "    bevel_intensity -= smoothstep(0.0, aa, d);\n"
    "    \n"
    "    // 3D Button bevel effect - raised center\n"
    "    float center_distance = length(p) / (min(iResolution.x, iResolution.y) * 0.5);\n"
    "    float button_height = 1.0 - smoothstep(0.0, 0.8, center_distance);\n"
    "    button_height = pow(button_height, 2.0); // Smooth falloff\n"
    "    \n"
    "    // Light direction for 3D effect (top-left lighting)\n"
    "    vec2 light_dir = normalize(vec2(-1.0, -1.0));\n"
    "    vec2 surface_normal = normalize(p);\n"
    "    float light_dot = dot(surface_normal, light_dir);\n"
    "    float button_lighting = 0.5 + light_dot * 0.3 * button_height;\n"
    "    \n"
    "    // Combine original bevel with 3D button effect\n"
    "    float combined_bevel = max(bevel_intensity, button_height * 0.4);\n"
    "    float angle = atan(p.y, p.x);\n"
    "    float gradient_wave = sin(angle * 2.0 - time * 2.5) * 0.5 + 0.5;\n"
    "    float highlight_factor = pow(gradient_wave, 8.0);\n"
    "    float brightness_modulator = 0.7 + highlight_factor * 0.6;\n"
    "    \n"
    "    // Apply button lighting to brightness\n"
    "    brightness_modulator *= button_lighting;\n"
    "    \n"
    "    // Shimmer effect - diagonal sweep across the surface\n"
    "    float shimmer_diagonal = (p.x + p.y) / (iResolution.x + iResolution.y);\n"
    "    float shimmer_wave = sin(shimmer_diagonal * 8.0 + time * 4.0);\n"
    "    float shimmer_intensity = smoothstep(0.6, 1.0, shimmer_wave) * 0.3;\n"
    "    shimmer_intensity *= smoothstep(-bevelWidth * 0.5, bevelWidth * 0.5, -abs(d));\n"
    "    \n"
    "    // Enhance shimmer on raised button areas\n"
    "    shimmer_intensity += button_height * 0.1;\n"
    "    \n"
    "    vec2 scaled_uv = (v_texcoord - 0.5) / bounce + 0.5;\n"
    "    scaled_uv = clamp(scaled_uv, 0.0, 1.0);\n"
    "    \n"
    "    // Apply Gaussian blur with dynamic intensity based on bevel\n"
    "    vec2 texel_size = 1.0 / iResolution;\n"
    "    float blur_intensity = combined_bevel * 0.8 + 0.2; // Use combined bevel for blur\n"
    "    vec4 tex_color = gaussianBlur(u_texture, scaled_uv, texel_size, blurRadius * blur_intensity);\n"
    "    vec3 final_bevel_color = bevelColor.rgb * brightness_modulator;\n"
    "    \n"
    "    // Apply shimmer to the final color\n"
    "    vec3 shimmer_color = vec3(1.0, 1.0, 0.9); // Slightly warm white shimmer\n"
    "    final_bevel_color = mix(final_bevel_color, shimmer_color, shimmer_intensity);\n"
    "    \n"
    "    vec3 final_rgb = mix(tex_color.rgb, final_bevel_color, combined_bevel * bevelColor.a);\n"
    "    float final_alpha = tex_color.a * shape_alpha;\n"
    "    // Debug: Uncomment to visualize bevel intensity\n"
    "    // frag_color = vec4(vec3(bevel_intensity), 1.0);\n"
    "    frag_color = vec4(final_rgb, final_alpha).bgra;\n"
    "}\n";

/*    //squezze genie
const char *genie_vertex_shader_src =
    "#version 300 es\n"
    "precision highp float;\n"
    "\n"
    "layout(location = 0) in vec2 position;\n"
    "layout(location = 1) in vec2 texcoord;\n"
    "\n"
    "uniform mat3 mvp;\n"
    "uniform float progress;\n"
    "uniform vec4 src_box;\n"
    "uniform vec4 target_box;\n"
    "uniform int upward;\n"
    "\n"
    "out vec2 v_texcoord;\n"
    "\n"
    "void main() {\n"
    "    vec2 pos = position;\n"
    "    \n"
    "    // Calculate normalized Y position (0 at bottom, 1 at top)\n"
    "    float norm_y = (upward == 1) ? texcoord.y : (1.0 - texcoord.y);\n"
    "    \n"
    "    // Create stepped width progression: 5% at bottom, incrementally to 100% at top\n"
    "    // Each step increases by ~5% (actually 5% per 20 steps for smooth progression)\n"
    "    float step_size = 0.05; // 5% increment\n"
    "    float min_width = 0.005; // 5% minimum width at bottom\n"
    "    \n"
    "    // Calculate which step we're in (0-19 steps for smooth transition)\n"
    "    float step_count = 5000.0;\n"
    "    float current_step = floor(norm_y * step_count);\n"
    "    \n"
    "    // Calculate width percentage for current step\n"
    "    // Bottom (step 0) = 5%, Top (step 5000) = 100%\n"
    "    float width_factor = min_width + (current_step / (step_count - 1.0)) * (1.0 - min_width);\n"
    "    \n"
    "    // Apply progressive squeeze based on progress and width factor\n"
    "    float squeeze_amount = progress * (1.0 - width_factor)+(sin(progress)/5.0);\n"
    "    \n"
    "    // Calculate source and target centers\n"
    "    float target_center_x = (target_box.x + target_box.z) * 0.5;\n"
    "    float src_center_x = (src_box.x + src_box.z) * 0.5;\n"
    "    \n"
    "    // Create trail path - bottom follows target, top stays at source initially\n"
    "    // The trail effect moves up the genie as progress increases\n"
    "    float trail_progress = progress * 2.0; // Speed up the trail effect\n"
    "    float trail_position = trail_progress - norm_y; // Trail moves from bottom to top\n"
    "    trail_position = clamp(trail_position, 0.0, 1.0);\n"
    "    \n"
    "    // Calculate center position based on trail - bottom warps to target first\n"
    "    float center_x = mix(src_center_x, target_center_x, trail_position);\n"
    "    \n"
    "    // Calculate window center for bottom squeeze centering\n"
    "    float window_center_x = 0.0;\n"
    "    \n"
    "    // Apply horizontal squeeze toward dynamic center\n"
    "    float distance_from_center = pos.x - center_x;\n"
    "    pos.x = center_x + distance_from_center * (1.0 - squeeze_amount );\n"
    "    \n"
    "    // Add subtle wave distortion for magical effect\n"
    "    float wave_intensity = squeeze_amount * 0.8;\n"
    "    float wave_freq = 1.0 + norm_y * 4.0; // Higher frequency at top\n"
    "    float wave = sin(norm_y * wave_freq + mix(-progress, progress, progress) * 6.28318) * wave_intensity;\n"
    "    \n"
    "    // Create trail-based wave positioning\n"
    "    float bottom_weight = 1.0 - norm_y; // Stronger effect at bottom\n"
    "    float trail_center = mix(center_x, target_center_x, trail_position);\n"
    "    pos.x = mix(center_x + (pos.x - center_x) + wave, trail_center + wave, bottom_weight * squeeze_amount) ;\n"
    "    \n"
    "    // Add slight vertical compression as it gets squeezed\n"
    "    float vertical_compress = squeeze_amount * 0.1;\n"
    "    pos.y = mix(pos.y, center_x, vertical_compress * norm_y);\n"
    "    \n"
    "    gl_Position = vec4((mvp * vec3(pos, 1.0)).xy, 0.0, 1.0);\n"
    "    v_texcoord = texcoord;\n"
    "}\n";
  */
  
  const char *genie_vertex_shader_src =
    "#version 300 es\n"
    "precision highp float;\n"
    "\n"
    "layout(location = 0) in vec2 position;\n"
    "layout(location = 1) in vec2 texcoord;\n"
    "\n"
    "uniform mat3 mvp;\n"
    "uniform float progress;\n"
    "uniform vec4 src_box;\n"
    "uniform vec4 target_box;\n"
    "uniform int upward;\n"
    "\n"
    "out vec2 v_texcoord;\n"
    "\n"
    "void main() {\n"
    "    vec2 pos = position;\n"
    "    \n"
    "    gl_Position = vec4((mvp * vec3(pos, 1.0)).xy, 0.0, 1.0);\n"
    "    v_texcoord = texcoord;\n"
    "}\n";
  static const char *genie_fragment_shader_src =
    "#version 300 es\n"
    "precision highp float;\n"
    "in vec2 v_texcoord;\n"
    "out vec4 frag_color;\n"
    "\n"
    "uniform sampler2D u_texture;\n"
    "\n"
    "void main() {\n"
    "    // The vertex shader did all the hard work. We just sample the texture.\n"
    "    // Flip the Y-coordinate as texture origin is often top-left.\n"
    "    frag_color = texture(u_texture, vec2(v_texcoord.x, 1.0 - v_texcoord.y));\n"
    "}\n";

// No changes needed for the vertex shader
static const char *solid_vertex_shader_src =
    "#version 300 es\n"
    "precision mediump float;\n"
    "layout(location = 0) in vec2 position;\n"
    "uniform mat3 mvp;\n"
    "out vec2 v_uv;\n"
    "void main() {\n"
    "    v_uv = position;\n"
    "    gl_Position = vec4((mvp * vec3(position, 1.0)).xy, 0.0, 1.0);\n"
    "}\n";

// *** MODIFIED FRAGMENT SHADER ***
static const char *solid_fragment_shader_src =
    "#version 300 es\n"
    "precision mediump float;\n"
    "uniform vec4 u_color;\n"
    "uniform float time;\n"
    "in vec2 v_uv;\n"
    "out vec4 frag_color;\n"
    "void main() {\n"
    "    // Center the UV coordinates to [-0.5, 0.5]\n"
    "    vec2 uv = v_uv - 0.5;\n"
    "    \n"
    "    // Distance from the center\n"
    "    float dist = length(uv);\n"
    "\n"
    "    // --- Circle Mask ---\n"
    "    // Define the circle's radius. 0.5 will touch the edges of the quad.\n"
    "    float radius = 0.35;\n"
    "    // Create a smooth mask that is 1.0 inside the circle and fades to 0.0 at the edge.\n"
    "    // This provides a clean, anti-aliased cutoff.\n"
    "    float circle_mask = 1.0 - smoothstep(radius - 0.01, radius, dist);\n"
    "\n"
    "    // If we are outside the circle, make the fragment transparent and exit.\n"
    "    if (circle_mask <= 0.0) {\n"
    "        discard; // More efficient than returning a transparent color\n"
    "    }\n"
    "    \n"
    "    // Create spiral angle\n"
    "    float angle = atan(uv.y, uv.x) + dist * 5.0 + time * 3.0;\n"
    "    \n"
    "    // Create star shape\n"
    "    float star = sin(angle * 5.0) * 0.5 + 0.5;\n"
    "    star = pow(star, 2.0);\n"
    "    \n"
    "    // The original 'radial' falloff is now replaced by our sharp circle_mask\n"
    "    star *= circle_mask;\n"
    "    \n"
    "    // Pulsate\n"
    "    float pulse = 0.8 + 0.2 * sin(time * 4.0);\n"
    "    star *= pulse;\n"
    "    \n"
    "    // Glow\n"
    "    float glow = exp(-dist * 3.0) * 1.5;\n"
    "    float intensity = star + glow;\n"
    "    \n"
    "    // Apply the circle mask to the final intensity as well\n"
    "    intensity *= circle_mask;\n"
    "\n"
    "    vec3 final_color = u_color.rgb * intensity;\n"
    "    frag_color = vec4(final_color, u_color.a * intensity);\n"
    "}\n";